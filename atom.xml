<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>pureblog</title>
    <link href="https://frasertweedale.github.io/blog-fp/atom.xml" rel="self" />
    <link href="https://frasertweedale.github.io/blog-fp" />
    <id>https://frasertweedale.github.io/blog-fp/atom.xml</id>
    <author>
        <name>Fraser Tweedale</name>
        <email>frase@frase.id.au</email>
    </author>
    <updated>2021-01-01T00:00:00Z</updated>
    <entry>
    <title>Fixing getExecutablePath on FreeBSD</title>
    <link href="https://frasertweedale.github.io/blog-fp/posts/2021-01-01-fixing-getExecutablePath-FreeBSD.html" />
    <id>https://frasertweedale.github.io/blog-fp/posts/2021-01-01-fixing-getExecutablePath-FreeBSD.html</id>
    <published>2021-01-01T00:00:00Z</published>
    <updated>2021-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="fixing-getexecutablepath-on-freebsd">Fixing <code>getExecutablePath</code> on FreeBSD</h1>
<p><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-Environment.html#v:getExecutablePath"><code>System.Environment.getExecutablePath</code></a> (part of the <em>base</em> library) returns the absolute pathname of the current executable. Except when it doesn’t. From my work on <a href="https://hackage.haskell.org/package/dyre">Dyre</a> (a <strong>dy</strong>namic <strong>re</strong>configuration system for Haskell programs) I discovered that <code>getExecutablePath</code> did not work properly on FreeBSD. Fixing it involved FreeBSD’s <a href="https://www.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;manpath=FreeBSD+12.2-RELEASE"><code>sysctl(3)</code></a> interface and the Haskell <a href="https://downloads.haskell.org/ghc/8.10.1/docs/html/users_guide/ffi-chap.html"><em>Foreign Function Interface</em></a> <em>(FFI)</em>.</p>
<h2 id="how-getexecutablepath-is-implemented">How <code>getExecutablePath</code> is implemented <a href="#how-getexecutablepath-is-implemented">§</a></h2>
<p>The <em>base</em> library is part of GHC. <code>getExecutablePath</code> is defined in <a href="https://gitlab.haskell.org/ghc/ghc/-/blob/ghc-8.6.5-release/libraries/base/System/Environment/ExecutablePath.hsc"><code>libraries/base/System/Environment/ExecutablePath.hsc</code></a> (link is to the GHC 8.6.5 version). <code>.hsc</code> files are processed by <a href="https://github.com/haskell/hsc2hs"><code>hsc2hs</code></a>, which provides helper directives for working with the FFI (it is also distributed with GHC).</p>
<p><code>ExecutablePath.hsc</code> uses C Preprocessor (CPP) directives to select different implementations of <code>getExecutablePath</code> for different operating systems. In GHC 8.6 and earlier there were platform-specific implementations for Linux, Mac OS X and Windows (all the <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms#tier-1-platforms">GHC Tier 1 platforms</a>). And there is a fallback implementation when no platform-specific implementation is available (we shall see that it has some problems). All of the implementations use the FFI to some extent.</p>
<h3 id="the-linux-implementation">The Linux implementation <a href="#the-linux-implementation">§</a></h3>
<p>Linux systems almost always mount <a href="https://en.wikipedia.org/wiki/Procfs#Linux"><code>procfs(5)</code></a>, a filesystem of information about running processes. Information about a particular process is published in files under <code>/proc/{pid}/</code>. A process can also find information about itself under <code>/proc/self/</code>.</p>
<p>A process can find out its own executable by reading <code>/proc/self/exe</code>, which is a symbolic link. And this is exactly what the implementation of <code>getExecutablePath</code> for Linux does:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>getExecutablePath <span class="ot">=</span> readSymbolicLink <span class="op">$</span> <span class="st">&quot;/proc/self/exe&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">readSymbolicLink ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">FilePath</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>readSymbolicLink file <span class="ot">=</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="co">-- uses readlink(3) via FFI</span></span></code></pre></div>
<h3 id="the-fallback-implementation-has-problems">The fallback implementation (has problems) <a href="#the-fallback-implementation-has-problems">§</a></h3>
<p>When the <em>base</em> library does not have an operating system-specific implementation for <code>getExecutablePath</code> it falls back to <code>argv[0]</code>: the first value in the program’s argument array. However, this is not a reliable way to determine the actual executable that supplied the program text. Many programs and environments manipulate the contents of <code>argv[0]</code>. The <code>execv*(3)</code> family of calls, which replaces the current process with a new process image, allow the caller to specify an arbitrary <code>argv</code>.</p>
<p>As an example of <code>argv[0]</code> manipulation, consider <a href="https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Process.html#v:executeFile"><code>System.Posix.Process.executeFile</code></a> from the <a href="https://hackage.haskell.org/package/unix"><em>unix</em></a> package. <code>executeFile</code> calls one of the <code>execv*(3)</code> subroutines (exactly which one depends on its own argument). But, as stated in the documentation:</p>
<blockquote>
<p>The basename (leading directory names suppressed) of the command is passed to execv* as <code>arg[0]</code>.</p>
</blockquote>
<p>So if you use <code>executeFile</code>, <code>argv[0]</code> of the resulting process does not contain a full pathname. And you may not be able to resolve the <em>basename</em> to an executable via the <code>PATH</code> environment variable. Worse still, you may successfully resolve it <em>to the wrong executable!</em></p>
<p>In fact, this was exactly the problem I experienced using <em>Dyre</em> on FreeBSD. <em>Dyre</em> automatically builds and caches an executable when it detects that configuration has changed, and <code>exec(3)</code>s the cached executable. On FreeBSD, the combination of <code>executeFile</code> <code>argv[0]</code> behaviour and use of the fallback <code>getExecutablePath</code> implementation caused <em>Dyre</em> to never recognise that it was running the cached executable. As a result, it entered an infinite loop of <code>execv*(3)</code>.</p>
<h2 id="querying-the-current-executable-on-freebsd">Querying the current executable on FreeBSD <a href="#querying-the-current-executable-on-freebsd">§</a></h2>
<p>It was clear that GHC needed a FreeBSD-specific implementation of <code>getExecutablePath</code>. So, what is the “proper” way to query the current process’ executable on FreeBSD?</p>
<p><a href="https://www.freebsd.org/cgi/man.cgi?query=procfs&amp;manpath=FreeBSD+12.2-RELEASE">FreeBSD does implement a <code>procfs</code></a>. Some of the file names differ from Linux’s <code>procfs</code>. For example, the “current executable” symlink path is <code>/proc/curproc/file</code> instead of <code>/proc/self/exe</code>. It would be a small change to parameterise the Linux implementation so that it can be used for FreeBSD. But unlike typical Linux systems, FreeBSD’s <code>procfs</code> is often unused and not even mounted (especially on servers). Therefore the <code>procfs</code> approach is not suitable for FreeBSD.</p>
<p>A bit of research revealed that the <a href="https://www.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;manpath=FreeBSD+12.2-RELEASE"><code>sysctl(3)</code></a> interface is the proper and ubiquitous way to query the executable path on FreeBSD. <code>sysctl(3)</code> exposes a <em>management information base (MIB)</em>, a tree structure where nodes are identified by a sequence of integers (<em>object identifier</em> or <em>OID</em>). For example, the kernel “maximum processes” setting has the OID <code>[1, 6]</code>. Some (but not all) OIDs have a string representation so that values can be queried or changed by the userland <code>sysctl(8)</code> utility:</p>
<pre><code>% sysctl kern.maxproc 
kern.maxproc: 3828</code></pre>
<p>To assist programmers reading and writing programs that use <code>sysctl(3)</code>, important OID components are defined in <code>&lt;sys/sysctl.h&gt;</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">/*</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="co"> * Top-level identifiers</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co"> */</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="pp">#define CTL_UNSPEC  0  </span><span class="co">/* unused */</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="pp">#define CTL_KERN    1  </span><span class="co">/* &quot;high kernel&quot;: proc, limits */</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>...</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="co">/*</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="co"> * CTL_KERN identifiers</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="co"> */</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>...</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a><span class="pp">#define KERN_MAXPROC  6  </span><span class="co">/* int: max processes */</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>...</span></code></pre></div>
<p>The OID containing a process’ executable pathname is <code>[1, 14, 12, $PID]</code> where <code>PID</code> is the process ID, or <code>-1</code> to refer to the current process. The C <code>#define</code>s for the first three components are <code>CTL_KERN</code>, <code>KERN_PROC</code>, and <code>KERN_PROC_PATHNAME</code>.</p>
<p>Now that we know the OID, consider the signature of <code>sysctl(3)</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">int</span> sysctl(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">int</span> *name,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    u_int namelen,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="dt">void</span> *oldp,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="dt">size_t</span> *oldlenp,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">void</span> *newp,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    <span class="dt">size_t</span> newlen);</span></code></pre></div>
<ul>
<li><p><code>name</code> is the OID; an array of <code>int</code>.</p></li>
<li><p><code>namelen</code> is the number of components in <code>name</code></p></li>
<li><p><code>oldp</code> is a pointer to a buffer to hold the current/old value. It can be <code>NULL</code>. It is a <code>void *</code> because sysctl nodes have a variety of types.</p></li>
<li><p><code>oldlenp</code> is an in/out argument that gives the size of <code>outp</code> before the call, and holds the actual size of the datum after the call (including when <code>oldp</code> is <code>NULL</code>).</p></li>
<li><p><code>newp</code> and <code>newlen</code> supply a new value. These are not needed for my use case and I will set them to <code>NULL</code> and <code>0</code> respectively.</p></li>
</ul>
<p>Therefore the procedure to query the current executable is:</p>
<ol type="1">
<li>Invoke <code>sysctl</code> with <code>oldp = NULL</code>.</li>
<li>Read <code>oldlenp</code> to determine size of datum.</li>
<li>Allocate big enough buffer.</li>
<li>Call <code>sysctl</code> again, with newly allocated buffer as <code>oldp</code>.</li>
<li>Process the data in <code>oldp</code>.</li>
<li>Free the buffer.</li>
</ol>
<p>This is what the FreeBSD-specific implementation of <code>getExecutablePath</code> must do.</p>
<h2 id="the-freebsd-implementation">The FreeBSD implementation <a href="#the-freebsd-implementation">§</a></h2>
<p>I will now walk through the different parts of the FreeBSD-specific implementation of <code>getExecutablePath</code>.</p>
<h3 id="c-preprocessor-guards">C Preprocessor guards <a href="#c-preprocessor-guards">§</a></h3>
<p>System-specific implementations are guarded by CPP conditionals:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="pp">#if defined(darwin_HOST_OS)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>... MacOS implementation</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="pp">#elif defined(linux_HOST_OS)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>... Linux implementation</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="pp">#elif defined(mingw32_HOST_OS)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>... Windows implementation</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a><span class="pp">#else</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>... fallback implementation</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
<p>I added the appropriate guard to encapsulate the FreeBSD-specific implementation:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="pp">#elif defined(freebsd_HOST_OS)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>... FreeBSD implementation</span></code></pre></div>
<p>Similarly, in the <code>import</code> area CPP conditionals wrap the FreeBSD-specific Haskell imports and C header includes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="pp">#elif defined(freebsd_HOST_OS)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Foreign.C</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Foreign.Marshal.Alloc</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Foreign.Marshal.Array</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Foreign.Ptr</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Foreign.Storable</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">System.Posix.Internals</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="pp">#include &lt;sys/types.h&gt;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="pp">#include &lt;sys/sysctl.h&gt;</span></span></code></pre></div>
<h3 id="foreign-import">Foreign import <a href="#foreign-import">§</a></h3>
<p>A <code>foreign import</code> declaration makes <code>sysctl(3)</code> available to Haskell code as <code>c_sysctl</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>foreign <span class="kw">import</span> ccall unsafe &quot;sysctl&quot;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  c_sysctl</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ptr</span> <span class="dt">CInt</span>   <span class="co">-- MIB</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">CUInt</span>      <span class="co">-- MIB size</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">CChar</span>  <span class="co">-- old / current value buffer</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">CSize</span>  <span class="co">-- old / current value buffer size</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">CChar</span>  <span class="co">-- new value</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">CSize</span>      <span class="co">-- new value size</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CInt</span>    <span class="co">-- result</span></span></code></pre></div>
<p>Observe the correspondence to the C function signature. Because this function is not referentially transparent (different calls with the same arguments could have different results) the result type is <code>IO CInt</code>.</p>
<h3 id="defining-the-mib">Defining the MIB <a href="#defining-the-mib">§</a></h3>
<p>The <code>hsc2hs</code> <code>(#const ...)</code> directive assists in the definition of the “current process executable” MIB:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">mib ::</span> [<span class="dt">CInt</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>mib <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  [ (<span class="op">#</span>const <span class="dt">CTL_KERN</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  , (<span class="op">#</span>const <span class="dt">KERN_PROC</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  , (<span class="op">#</span>const <span class="dt">KERN_PROC_PATHNAME</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  , <span class="op">-</span><span class="dv">1</span>   <span class="co">-- current process</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  ]</span></code></pre></div>
<h3 id="defining-getexecutablepath">Defining <code>getExecutablePath</code> <a href="#defining-getexecutablepath">§</a></h3>
<p>The <code>getExecutablePath</code> implementation closely follows the abstract procedure outlined above. So here it is, broken up with commentary (<a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/1276/diffs">full diff</a>):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>getExecutablePath <span class="ot">=</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  withArrayLen mib <span class="op">$</span> \n mibPtr <span class="ot">-&gt;</span> <span class="kw">do</span></span></code></pre></div>
<p><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Marshal-Array.html#v:withArrayLen"><code>withArrayLen</code></a> converts a Haskell list to a heap-allocated C array, passing it (as a pointer) <em>and</em> its length to the given continuation function. It will free the array after the continuation returns.</p>
<pre><code>    let mibLen = fromIntegral n
    alloca $ \bufSizePtr -&gt; do</code></pre>
<p>Convert <code>mibLen</code> from <code>Int</code> to <code>CInt</code>. <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Marshal-Alloc.html#v:alloca"><code>alloca</code></a> allocates memory to hold a <code>CSize</code> (<code>size_t</code>) and passes a pointer to that memory to the given continuation (and frees it when the continuation returns).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>      status <span class="ot">&lt;-</span> c_sysctl mibPtr mibLen</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>                         nullPtr bufSizePtr nullPtr <span class="dv">0</span></span></code></pre></div>
<p>Call <code>sysctl(3)</code> with <code>oldp = NULL</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>      <span class="kw">case</span> status <span class="kw">of</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>        <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>          reqBufSize <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="op">&lt;$&gt;</span> peek bufSizePtr</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>          allocaBytes reqBufSize <span class="op">$</span> \buf <span class="ot">-&gt;</span> <span class="kw">do</span></span></code></pre></div>
<p>If the initial call to <code>sysctl(3)</code> succeeded, <code>bufSizePtr</code> holds the required buffer size. <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#v:peek"><code>peek</code></a> reads the value. Then <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Marshal-Alloc.html#v:allocaBytes"><code>allocaBytes</code></a> allocates that much space on the heap and passes the pointer to the continuation (and frees it after).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>            newStatus <span class="ot">&lt;-</span> c_sysctl mibPtr mibLen</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>                                  buf bufSizePtr nullPtr <span class="dv">0</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>            <span class="kw">case</span> newStatus <span class="kw">of</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>              <span class="dv">0</span> <span class="ot">-&gt;</span> peekFilePath buf</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>              _ <span class="ot">-&gt;</span> throwErrno <span class="st">&quot;getExecutablePath&quot;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>        _ <span class="ot">-&gt;</span> throwErrno <span class="st">&quot;getExecutablePath&quot;</span></span></code></pre></div>
<p>Call <code>sysctl(3)</code> again, this time using the new buffer (<code>buf</code>) as <code>oldp</code>. If successful, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-Posix-Internals.html#v:peekFilePath"><code>peekFilePath</code></a> converts the C string to a Haskell <code>FilePath</code>. Although it is three continuations deep, this <code>FilePath</code> will be the return value. If either call to <code>sysctl(3)</code> failed, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-C-Error.html#v:throwErrno"><code>throwErrno</code></a> throws an <code>IOError</code>.</p>
<h2 id="conclusion">Conclusion <a href="#conclusion">§</a></h2>
<p>This was a small enhancement to GHC, but for me a critical one. I submitted a <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/1276">merge request</a>. It was quickly accepted and the fix was released in GHC 8.8.1.</p>
<p>Although I didn’t address it in my pull request, there is an error in the <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-Environment.html#v:getExecutablePath"><code>getExecutablePath</code></a> documentation. The <code>argv[0]</code> fallback implementation <em>does not</em> necessarily return an absolute pathname, as claimed. It would be better if platform-specific and fallback behaviours were fully explained.</p>
<p>If you would like to see fixes, enhancements or documentation improvements (<em>hint, hint</em>) in GHC, do not be afraid! GHC is a huge project. But after you work out what bits go where, it’s not necessarily hard to make changes. It helps a lot that it is written in Haskell! You can submit a pull request via the <a href="https://gitlab.haskell.org/ghc/ghc">Haskell GitLab instance</a> (you can sign in with GitHub credentials). Apart from this FreeBSD-related fix I have submitted a couple other changes to GHC. I have found the GHC developers are always friendly and willing to assist new and less experienced contributors.</p>
<p>By the way, I do not mean to trivialise GHC development. Some parts of it are truly daunting. But many parts are not. I believe that no Haskell developer—not even beginners—should be daunted by the <em>idea</em> of contributing to GHC, or believe that they cannot do it.</p>
<p>In terms of the <a href="https://downloads.haskell.org/ghc/8.10.1/docs/html/users_guide/ffi-chap.html">Haskell FFI</a>, this change captured a few interesting concepts, including:</p>
<ul>
<li>allocation memory of arbitrary size (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Marshal-Alloc.html#v:alloca"><code>alloca</code></a>)</li>
<li>converting Haskell lists to C arrays (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Marshal-Array.html#v:withArrayLen"><code>withArrayLen</code></a>)</li>
<li>reading data from pointers (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#v:peek"><code>peek</code></a>)</li>
<li>referencing constants via the <code>hsc2hs</code> <code>(#const ...)</code> directive</li>
</ul>
<p>The <em>“allocate, call continuation and cleanup”</em> pattern is prevalent in the Haskell <code>Foreign.*</code> modules. Even this small example goes three layers deep. More complex FFI use cases can go much deeper.</p>
<p>Important FFI topics that this case study did not engage include marshalling structs (something <code>hsc2hs</code> helps), <code>ForeignPtr</code>s and finalizers, and callbacks. So although I hope this case study may be instructive in <em>some</em> aspects of Haskell FFI usage, it is far from comprehensive.</p>]]></summary>
</entry>
<entry>
    <title>Refactoring using type classes and optics</title>
    <link href="https://frasertweedale.github.io/blog-fp/posts/2020-12-21-refactoring-type-classes-optics.html" />
    <id>https://frasertweedale.github.io/blog-fp/posts/2020-12-21-refactoring-type-classes-optics.html</id>
    <published>2020-12-21T00:00:00Z</published>
    <updated>2020-12-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="refactoring-using-type-classes-and-optics">Refactoring using type classes and optics</h1>
<p>Often when writing programs and functions, one starts off with concrete types that solve the problem at hand. At some later time, due to emerging requirements or observed patterns, or just to improve code readability and reusability, we refactor to make the code more polymorphic. The importance of not breaking your API typically ranges from <em>nice to have</em> (e.g. minimise rework but not otherwise necessary) to <em>paramount</em> (e.g. in a popular, foundational library). This post is a case study of a refactoring in the <a href="https://hackage.haskell.org/package/jose"><em>jose</em></a> library demonstrating how <em>type classes</em> help achieve API stability while admitting new use cases. Served with a side of <em>classy optics</em>.</p>
<h2 id="background-verifying-a-jws">Background: verifying a JWS <a href="#background-verifying-a-jws">§</a></h2>
<p>In the <em>jose</em> library, the <code>verifyJWS</code> function verifies a <em>JSON Web Signature (JWS)</em> object:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>verifyJWS</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">  ::</span>  ( <span class="dt">HasAlgorithms</span> a, <span class="dt">HasValidationPolicy</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>      , <span class="dt">AsError</span> e, <span class="dt">MonadError</span> e m</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>      , <span class="dt">HasJWSHeader</span> h, <span class="dt">HasParams</span> h</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>      )</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="ot">=&gt;</span> a</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">JWK</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">JWS</span> h</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p><code>verifyJWS</code> is applied to a configuration value, a <em>JSON Web Key (JWK)</em> to use for validation, and the JWS, and returns <code>()</code> on success otherwise throws an error.</p>
<p>A JWS can have multiple signatures, each by a different key. If an application requires all signatures to be valid, it is difficult to perform the correct validation using the existing <code>verifyJWS</code> function. Unsurprisingly, someone <a href="https://github.com/frasertweedale/hs-jose/issues/35">raised an issue</a> to address this. Specifically, the issue asked for a way to use a <em>JWK Set</em> instead of a single <em>JWK</em>, where the JWK Set contains all the keys that can be used for validation (and possibly others). JWK Set is <a href="https://tools.ietf.org/html/rfc7517#section-5">defined by RFC 7515</a> as an array of JWKs. Its definition in <em>jose</em> is below (it is a <code>newtype</code> because it needs custom instances for JSON encoding/decoding).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">JWKSet</span> <span class="ot">=</span> <span class="dt">JWKSet</span> [<span class="dt">JWK</span>]</span></code></pre></div>
<p>How can we support verification when the caller has a <code>JWKSet</code>? Do we add an alternative verification function that applies to <code>JWKSet</code> instead of <code>JWK</code>? I did not want multiple functions in the API for essentially the same thing. We could make the caller construct a singleton <code>JWKSet</code>, but changing the signature of <code>verifyJWS</code> would break the API, so we won’t do that either.</p>
<h2 id="looking-beyond-jwk-set">Looking beyond JWK Set <a href="#looking-beyond-jwk-set">§</a></h2>
<p>At first, we could only validate with a single <code>JWK</code> at a time. Now, we want to be able to handle a <code>JWKSet</code> too. So are there other “key-bearing” structures we might need to handle?</p>
<p>Indeed there are. One might want to use a <code>[JWK]</code>, <code>NonEmpty JWK</code> or other container types. Many container types constructors have an instance of <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html"><code>Foldable</code></a>, so we could try to use that abstraction. This is rather boring, but it’s an additional valid use case. So, can we refactor <code>verifyJWS</code> to use <code>Foldable</code>?</p>
<p>It is a nice idea, but the answer is <em>no</em>. First, <code>Foldable t =&gt; t</code> has kind <code>(* -&gt; *)</code>, but <code>JWKSet</code> has kind <code>*</code>. Turning <code>JWKSet</code> into a generic container doesn’t make sense either. Second, we still want our function to work with a plain old JWK, which also has kind <code>*</code>.</p>
<p>At this point I realised that that if I want to make <code>verifyJWS</code> polymorphic, <em>and</em> support <code>JWK</code> and <code>JWKSet</code> and arbitrary containers as “key sources”, <em>and</em> avoid breaking the API, there was only one way forward. It was necessary to define a new type class to represent a “provider of keys”:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">JWKStore</span> a <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="ot">  keys ::</span> <span class="op">???</span></span></code></pre></div>
<p>What should the type of <code>keys</code> be? Conceptually, it would be applied to a <code>JWKStore a =&gt; a</code> and yield the <code>JWK</code> values contained within. For the validation use case there is no need to be able to add or update keys, i.e. it is read-only. <code>Fold a JWK</code> is a good fit for the requirement. A <a href="https://hackage.haskell.org/package/lens-4.15/docs/Control-Lens-Fold.html"><code>Fold</code></a> is a read-only <em>optic</em> that that can retrieve multiple (zero or more) values. The beauty of optics is that they can be composed together and <code>Fold</code> is no different. The <code>Fold</code> type is provided by the <a href="https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Lens.html"><em>lens</em></a> library, along with a bunch of useful helper functions.</p>
<p>The key store interface (type class) and instances were defined as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">JWKStore</span> a <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="ot">  keys ::</span> <span class="dt">Fold</span> a <span class="dt">JWK</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">JWKStore</span> <span class="dt">JWK</span> <span class="kw">where</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  keys <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> <span class="dt">JWKStore</span> (t <span class="dt">JWK</span>) <span class="kw">where</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  keys <span class="ot">=</span> folding <span class="fu">id</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">JWKStore</span> <span class="dt">JWKSet</span> <span class="kw">where</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>  keys <span class="ot">=</span> folding (\(<span class="dt">JWKSet</span> xs) <span class="ot">-&gt;</span> xs)</span></code></pre></div>
<p>(Note that the instance for <code>Foldable t =&gt; t JWK</code> requires the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances"><code>FlexibleInstances</code></a> GHC extension.)</p>
<p>The updated type signature for <code>verifyJWS</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>verifyJWS</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">  ::</span>  ( <span class="dt">HasAlgorithms</span> a, <span class="dt">HasValidationPolicy</span> a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>      , <span class="dt">AsError</span> e, <span class="dt">MonadError</span> e m</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>      , <span class="dt">HasJWSHeader</span> h, <span class="dt">HasParams</span> h</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>      , <span class="dt">JWKStore</span> k</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>      )</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>  <span class="ot">=&gt;</span> a</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>  <span class="ot">-&gt;</span> k</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">JWS</span> h</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>  <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>Existing code applying <code>verifyJWS</code> to a <code>JWK</code> works without changes. The only internal change that was needed was to apply <code>anyOf keys</code> to the existing test. (<a href="https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Fold.html#v:anyOf"><code>anyOf</code></a> is a function provided in <em>lens</em> that returns <code>True</code> if any target of a <code>Fold</code> satisfies a predicate.) The line:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>validate s <span class="ot">=</span> verifySig p s k <span class="op">==</span> <span class="dt">Right</span> <span class="dt">True</span></span></code></pre></div>
<p>became:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>validate s <span class="ot">=</span> anyOf keys ((<span class="op">==</span> <span class="dt">Right</span> <span class="dt">True</span>) <span class="op">.</span> verifySig p s) k</span></code></pre></div>
<p>The technique of using type classes to select optics is called <em>classy optics</em>. The terms <em>classy lenses</em> and <em>classy prisms</em> are also used when referring to those kinds of optics specifically.</p>
<p>My goal was to support validation using a <code>JWKSet</code> without breaking the API or adding more functions. At this point the goal has been achieved. But I mentioned above that <code>JWKSet</code> and <code>Foldable t =&gt; t JWK</code> were the boring use cases. Let’s discuss some <em>interesting</em> ones!</p>
<h2 id="efficient-key-lookup">Efficient key lookup <a href="#efficient-key-lookup">§</a></h2>
<p>JWS signatures each have a <em>header</em> which, at minimum, indicates the algorithm used (the <code>"alg"</code> member). It can optionally contain other data including a Key ID (<code>"kid"</code>), thumbprint of an X.509 certificate containing the key used make the signature (<code>"x5t@S256"</code>), a JWK for the signing key (<code>"jwk"</code>), and so on. It is not a stretch that if your use case involves many signing keys, you would want to use data available from the signature header to speed up key lookup. Such techniques are common in applied cryptography where many keys are involved. For example, X.509 certificates contain an <em>Authority Key Identifier</em> field, and certificate databases usually provide efficient lookup by key identifier.</p>
<p>So in addition to being able to enumerate keys, we want <code>JWKStore</code> instances to potentially be able to look up keys based on data in the JWS header. I added another function to the type class to accomplish this, along with a sensible default implementation:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">JWKStore</span> a <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">  keys ::</span> <span class="dt">Fold</span> a <span class="dt">JWK</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">  keysFor ::</span> (<span class="dt">HasJWSHeader</span> h) <span class="ot">=&gt;</span> h <span class="ot">-&gt;</span> <span class="dt">Fold</span> a <span class="dt">JWK</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  keysFor _ <span class="ot">=</span> keys</span></code></pre></div>
<p>As an example, we can instantiate <code>JWKStore a =&gt; a</code> at a data type based on <code>HashMap</code>, where keys are indexed by key identifier (an arbitrary string). The <code>keysFor</code> function can efficiently search for a <code>JWK</code> based on the <code>"kid"</code> (Key ID) header parameter from the JWS header. If the <code>"kid"</code> parameter is missing, it yields all the <code>keys</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">KidMap</span> <span class="ot">=</span> <span class="dt">KidMap</span> {<span class="ot"> getMap ::</span> <span class="dt">HashMap</span> <span class="dt">String</span> <span class="dt">JWK</span> }</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">JWKStore</span> <span class="dt">KidMap</span> <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  keys <span class="ot">=</span> folding getMap</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  keyFor h <span class="ot">=</span> <span class="kw">case</span> preview (kid <span class="op">.</span> _Just <span class="op">.</span> param) h <span class="kw">of</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="dt">Just</span> k  <span class="ot">-&gt;</span> folding (<span class="fu">lookup</span> k <span class="op">.</span> getMap)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> keys</span></code></pre></div>
<h2 id="a-jwkstore-is-not-just-for-jws">A <code>JWKStore</code> is not just for JWS <a href="#a-jwkstore-is-not-just-for-jws">§</a></h2>
<p>Recall the type of <code>keysFor</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">keysFor ::</span> (<span class="dt">HasJWSHeader</span> h) <span class="ot">=&gt;</span> h <span class="ot">-&gt;</span> <span class="dt">Fold</span> a <span class="dt">JWK</span></span></code></pre></div>
<p><code>h</code> has an explicit <code>HasJWSHeader</code> type class constraint, which allows the implementation to use any information available via that type class to decide what to do. For JWS we’re basically done, but we have forgotten about <em>JSON Web Encryption (JWE)</em>. The concept of looking up keys in a key database applies to JWE as well as JWS, but the <code>HasJWSHeader</code> constraint is not suitable when you have a <em>JWE header</em>.</p>
<p>But JWE headers and JWS headers consist of mostly the same fields, with the same types and semantics. So instead of having a type class constraint mentioning the kind of header, we can define a type class for every shared header parameter and constrain <code>keysFor</code> to <em>all of them</em>. I will use classy optics again (<a href="https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Lens.html">lenses</a> this time). There are eleven header fields shared by JWS and JWE headers, but for brevity I’ll pretend there are only three.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">HasAlg</span> a <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="ot">  alg ::</span> <span class="dt">Lens&#39;</span> a (<span class="dt">HeaderParam</span> <span class="dt">JWA.JWS.Alg</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">HasKid</span> a <span class="kw">where</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="ot">  kid ::</span> <span class="dt">Lens&#39;</span> a (<span class="dt">Maybe</span> (<span class="dt">HeaderParam</span> <span class="dt">String</span>))</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">HasX5tS256</span> a <span class="kw">where</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="ot">  x5tS256 ::</span> <span class="dt">Lens&#39;</span> a (<span class="dt">Maybe</span> (<span class="dt">HeaderParam</span> <span class="dt">Types.Base64SHA256</span>))</span></code></pre></div>
<p>The class definitions are mundane, as are the instances for <code>JWSHeader</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">HasAlg</span> <span class="dt">JWSHeader</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  alg f h<span class="op">@</span>(<span class="dt">JWSHeader</span> { _jwsHeaderAlg <span class="ot">=</span> a }) <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="fu">fmap</span> (\a&#39; <span class="ot">-&gt;</span> h { _jwsHeaderAlg <span class="ot">=</span> a&#39; }) (f a)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">HasKid</span> <span class="dt">JWSHeader</span> <span class="kw">where</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>  kid f h<span class="op">@</span>(<span class="dt">JWSHeader</span> { _jwsHeaderKid <span class="ot">=</span> a }) <span class="ot">=</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    <span class="fu">fmap</span> (\a&#39; <span class="ot">-&gt;</span> h { _jwsHeaderKid <span class="ot">=</span> a&#39; }) (f a)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">HasX5tS256</span> <span class="dt">JWSHeader</span> <span class="kw">where</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>  x5tS256 f h<span class="op">@</span>(<span class="dt">JWSHeader</span> { _jwsHeaderX5tS256 <span class="ot">=</span> a }) <span class="ot">=</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>    <span class="fu">fmap</span> (\a&#39; <span class="ot">-&gt;</span> h { _jwsHeaderX5tS256 <span class="ot">=</span> a&#39; }) (f a)</span></code></pre></div>
<p>And finally, the updated <code>keysFor</code> type signature:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">JWKStore</span> a <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="ot">  keys ::</span> <span class="dt">Fold</span> a <span class="dt">JWK</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  keysFor</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="ot">    ::</span> (<span class="dt">HasAlg</span> h, <span class="dt">HasKid</span> h, <span class="dt">HasX5tS256</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    <span class="ot">=&gt;</span> h</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Fold</span> a <span class="dt">JWK</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>  keysFor _ <span class="ot">=</span> keys</span></code></pre></div>
<h2 id="further-development">Further development <a href="#further-development">§</a></h2>
<p>I mentioned that the refactor I outlined in this post was not the end of the story. In fact, much more was done since I performed this initial refactoring:</p>
<ul>
<li><p>Implementing an <a href="https://github.com/frasertweedale/hs-jose/commit/e15ac3a34cf4a2f193f4b68345d8839c791ec2ed">effectful key store</a>, so that key lookup can perform I/O.</p></li>
<li><p>Allow the key store to <a href="https://github.com/frasertweedale/hs-jose/commit/dedcd82787bb533885211c3e7ff8f8bcd4adc3c9">inspect the JWS payload</a> during lookup. The motivating use case is to allow key lookup to read the JWT <code>"iss"</code> (Issuer) field.</p></li>
<li><p>Parameterised the key store <a href="https://github.com/frasertweedale/hs-jose/commit/2fc1b0b8e7196f90ce68bae93fde591812dd3f22">over the header type</a>. This allows implementations to use data from extended header types during key lookup.</p></li>
</ul>
<p>All of these features involved adding type parameters to the <code>JWKStore</code> class. Again, I achieved <strong>backwards compatible</strong> admittance of new features through increased generality.</p>
<p>However, parameterisation over the header type did make my use of classy lenses (as described in this post) obsolete. It is always beneficial to define classy lenses and use them to document (and restrict) functions that access specific fields of “types that have those fields”. But if the type is even more general than that, there’s nothing more to do.</p>
<p>Finally, implementing payload inspection was incompatible with having a unified key store interface for both decryption and verification keys. (You can’t use the payload to help choose a decryption key becaues it is encrypted!) Therefore I <a href="https://github.com/frasertweedale/hs-jose/commit/c08431fb31fb2a0bae86f6c4a5af20428e681230">renamed <code>JWKStore</code> to <code>VerificationKeyStore</code></a>.</p>
<h2 id="conclusion">Conclusion <a href="#conclusion">§</a></h2>
<p>Let’s recap what this post was all about and draw some conclusions.</p>
<p>First, I discussed a requirement to generalise the <a href="https://hackage.haskell.org/package/jose"><em>jose</em></a> library’s JWS validation code. Previously, validation worked only with a single <code>JWK</code>. It needed to handle other use cases like <code>JWKSet</code> or key databases. I defined the <code>JWKStore</code> <strong>type class</strong>, which provides access to JWKs inside arbitrary data types, and refactored <code>verifyJWS</code> to use it. Instances for <code>JWK</code> and <code>JWKSet</code> are included. The refactor was a <strong>backwards-compatible generalisation</strong> of <code>verifyJWS</code> function, so existing code using <em>jose</em> continued to work without changes.</p>
<p>After this, I added another function to <code>JWKStore</code> to allow instances to support efficient key lookup. Finally, I observed that key databases are needed for JWE as well as JWS, and further generalised <code>JWKStore</code> to account for this.</p>
<p><strong>Classy optics</strong> were an important part of the implementation resulting from this refactoring effort. They were employed in two different ways. First, a <a href="https://hackage.haskell.org/package/lens-4.15/docs/Control-Lens-Fold.html"><code>Fold</code></a> provides a read-only, composable interface to the keys in a <code>JWKStore</code>. Second, I used classy <a href="https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Lens.html">lenses</a> to parameterise key lookup over the fields that are common to both JWS and JWE headers. Classy lenses provide the generality we desire <em>and</em> improve readability by documenting the data that can be used during key lookup (and enforcing these restrictions).</p>
<p>Finally I briefly discussed subsequent developments of the key store interface in <em>jose</em>. The important thing to note is that substantive <strong>backwards-compatible</strong> enhancements were achieved through <strong>more generality</strong> (polymorphism).</p>
<p>So here are some final take-aways:</p>
<ul>
<li><p>Starting with code that handles a single use case is normal. But you may have to revisit and change that code (especially in libraries).</p></li>
<li><p>When you have to revisit some code to admit more use cases, it is worth having a good think about what other use cases exist. Discovering a more general (polymorphic) interface is preferable to multiple concrete interfaces. There will be <strong>less code</strong> to document and maintain, <strong>less potential confusion</strong> for users, and more potential for <strong>reuse</strong> (more use cases admitted).</p></li>
<li><p>Introducing a <strong>type class</strong> may let you admit new use cases while preserving backwards compatibility for library users. Further parameterising an existing type class can also achieve this. I have done this many times (in <em>jose</em> and other projects) and have <em>never</em> regretted introducing another type parameter.</p></li>
<li><p><strong>Classy optics</strong> enable reuse; more types can be used with the function, including types you didn’t even know about. And they document and enforce the data a function can access, which is helpful when dealing with record types.</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Adding section links to Hakyll articles with Text.Pandoc.Walk</title>
    <link href="https://frasertweedale.github.io/blog-fp/posts/2020-12-10-hakyll-section-links.html" />
    <id>https://frasertweedale.github.io/blog-fp/posts/2020-12-10-hakyll-section-links.html</id>
    <published>2020-12-10T00:00:00Z</published>
    <updated>2020-12-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="adding-section-links-to-hakyll-articles-with-text.pandoc.walk">Adding section links to Hakyll articles with <code>Text.Pandoc.Walk</code></h1>
<p>It is handy to be able to link to section headings in long articles. <a href="https://pandoc.org/">Pandoc</a> and <a href="https://jaspervdj.be/hakyll/">Hakyll</a> don’t do that out of the box. But they give you all the power you need to implement it yourself. In this post I’ll show you how.</p>
<h2 id="objective">Objective <a href="#objective">§</a></h2>
<p>The main objective is to provide links (HTML <code>&lt;a&gt;</code> element) to section headings. They should be located near or within the heading element. Having them in the document will make it easy for readers to grab a link to a specific section of the article. (I myself often want to do this!)</p>
<p>You could make the whole heading a link, but I like the approach that reveals a link when the pointer hovers over the heading. Some sites use a pilcrow (¶), pound (#) or a link symbol (🔗) as the link text. I will use a section sign (§).</p>
<h2 id="building-blocks">Building blocks <a href="#building-blocks">§</a></h2>
<p>Pandoc does set the <code>id</code> attribute of HTML heading elements to a value derived from the heading text. For example, one of my previous posts had a section headed <a href="2020-03-31-quickcheck-hedgehog.html#probabilities">Probabilities</a>. The resulting HTML for the heading is:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">&lt;h2</span><span class="ot"> id=</span><span class="st">&quot;probabilities&quot;</span><span class="kw">&gt;</span>Probabilities<span class="kw">&lt;/h2&gt;</span></span></code></pre></div>
<p>The value of the <code>id</code> attribute will be the <code>href</code> target of the <code>&lt;a&gt;</code> element we create (with <code>#</code> prepended to make it a URI fragment).</p>
<p>Hakyll provides the <code>pandocCompilerWithTransform</code> function for compiling documents using Pandoc and applying an arbitrary transformation to them. It has the type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>pandocCompilerWithTransform</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ot">  ::</span> <span class="dt">ReaderOptions</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">WriterOptions</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="ot">-&gt;</span> (<span class="dt">Pandoc</span> <span class="ot">-&gt;</span> <span class="dt">Pandoc</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)</span></code></pre></div>
<p>Note the <code>(Pandoc -&gt; Pandoc)</code> argument. This is the tranformation function. It works with the <a href="https://hackage.haskell.org/package/pandoc-types-1.21/docs/Text-Pandoc-Definition.html#t:Pandoc"><code>Pandoc</code></a> native AST data type, rather than HTML or the input type (e.g. Markdown).</p>
<p>For constructing such a transformation, Pandoc provides the <a href="https://hackage.haskell.org/package/pandoc-types-1.21/docs/Text-Pandoc-Walk.html#v:walk"><code>Text.Pandoc.Walk</code></a> module and the <code>walk</code> function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">walk ::</span> (<span class="dt">Walkable</span> a b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span></code></pre></div>
<p><code>walk f x</code> walks the structure <code>x :: b</code> (bottom up) and replaces every occurrence of a value of type <code>a</code> with the result of applying <code>f :: (a -&gt; a)</code> to it.</p>
<p>There are many instances of <code>Walkable</code>. We are interested in the one that visits all the <code>Block</code> elements (that’s what headings are) in the <code>Pandoc</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Walkable</span> <span class="dt">Block</span> <span class="dt">Pandoc</span></span></code></pre></div>
<h2 id="putting-it-together">Putting it together <a href="#putting-it-together">§</a></h2>
<p>I needed a handful of Pandoc constructors to implement the transformation. The <code>Header</code> constructor (of the <code>Block</code> data type) represents a document (sub)heading with <code>Int</code> depth, attributes, and the list of <code>Inline</code> elements that constitute the header content.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Block</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="op">...</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Header</span> <span class="dt">Int</span> <span class="dt">Attr</span> [<span class="dt">Inline</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  <span class="op">...</span></span></code></pre></div>
<p>I also had to construct a <code>Link</code> (one of the cases of the <code>Inline</code> data type). A <code>Link</code> has attributes, content (<code>[Inline]</code>) and a target. I also used the <code>Str</code> and <code>Space</code> constructors.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Inline</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    <span class="ot">=</span> <span class="dt">Str</span> <span class="dt">Text</span>              <span class="co">-- ^ Literal text</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="op">...</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">Space</span>                 <span class="co">-- ^ Inter-word space</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span class="op">...</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">Link</span> <span class="dt">Attr</span> [<span class="dt">Inline</span>] <span class="dt">Target</span></span></code></pre></div>
<p>By the way, <code>Attr</code> and <code>Target</code> are defined as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">-- id, classes and key-value pairs</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Attr</span> <span class="ot">=</span> (<span class="dt">Text</span>, [<span class="dt">Text</span>], [(<span class="dt">Text</span>, <span class="dt">Text</span>)])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">-- URI, title</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Target</span> <span class="ot">=</span> (<span class="dt">Text</span>, <span class="dt">Text</span>)</span></code></pre></div>
<p>With these constructors in hand, here is the whole transformation function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">addSectionLinks ::</span> <span class="dt">Pandoc</span> <span class="ot">-&gt;</span> <span class="dt">Pandoc</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>addSectionLinks <span class="ot">=</span> walk f <span class="kw">where</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  f (<span class="dt">Header</span> n attr<span class="op">@</span>(idAttr, _, _) inlines) <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">1</span> <span class="ot">=</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="kw">let</span> link <span class="ot">=</span> <span class="dt">Link</span> nullAttr [<span class="dt">Str</span> <span class="st">&quot;§&quot;</span>] (<span class="st">&quot;#&quot;</span> <span class="op">&lt;&gt;</span> idAttr, <span class="st">&quot;&quot;</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="kw">in</span> <span class="dt">Header</span> n attr (inlines <span class="op">&lt;&gt;</span> [<span class="dt">Space</span>, link])</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  f x <span class="ot">=</span> x</span></code></pre></div>
<p>Note that we only apply this change to headings of depth greater than one. I do not need to provide a link for the article title, which is at the top of the page. For all other headers, we add a <code>Link</code> to its inline content, where the target is the fragment pointing at the <code>idAddr</code> of the header itself.</p>
<p>To apply the transformation, I had to replace a single occurrence of:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">pandocCompiler ::</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)</span></code></pre></div>
<p>with:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>pandocCompilerWithTransform</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>        defaultHakyllReaderOptions</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>        defaultHakyllWriterOptions</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>        addSectionLinks</span></code></pre></div>
<h2 id="style">Style <a href="#style">§</a></h2>
<p>I want to hide the heading link unless the cursor is hovering over the heading. I would like to accomplish it with this small dose of CSS:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="in">:is(h2, h3, h4, h5, h6)</span> a {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span class="kw">text-decoration</span>: <span class="dv">none</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="kw">color</span>: <span class="cn">grey</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    <span class="kw">visibility</span>: <span class="dv">hidden</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>}</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="in">:is(h2, h3, h4, h5, h6):hover</span> a {</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    <span class="kw">visibility</span>: <span class="dv">visible</span><span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>The <code>is()</code> pseudo-class function matches anything that matches the selector arguments, avoiding tedious repetition. It is part of CSS <a href="https://www.w3.org/TR/selectors-4/#matches">Selectors Level 4</a>, which is still a draft. Firefox and Safari fully support it but unfortunately other browsers are <a href="https://caniuse.com/css-matches-pseudo">lagging behind</a>. So I am stuck with the tedious repetition for now:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>h2 a<span class="op">,</span> h3 a<span class="op">,</span> h4 a<span class="op">,</span> h5 a<span class="op">,</span> h6 a {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>    <span class="kw">text-decoration</span>: <span class="dv">none</span><span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="kw">color</span>: <span class="cn">grey</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    <span class="kw">visibility</span>: <span class="dv">hidden</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>}</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>h2<span class="in">:hover</span> a<span class="op">,</span> h3<span class="in">:hover</span> a<span class="op">,</span> h4<span class="in">:hover</span> a<span class="op">,</span> h5<span class="in">:hover</span> a<span class="op">,</span> h6<span class="in">:hover</span> a {</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>    <span class="kw">visibility</span>: <span class="dv">visible</span><span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>I also used <code>text-decoration</code> and <code>color</code> to make the link appearance clean and understated.</p>
<h2 id="conclusion">Conclusion <a href="#conclusion">§</a></h2>
<p>As a result of this change, the HTML emitted for section headers (of depth &gt; 1) looks like:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">&lt;h2</span><span class="ot"> id=</span><span class="st">&quot;probabilities&quot;</span><span class="kw">&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  Probabilities <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#probabilities&quot;</span><span class="kw">&gt;</span>§<span class="kw">&lt;/a&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="kw">&lt;/h2&gt;</span></span></code></pre></div>
<p>You can experience the results for yourself, right here on this page (and in my other posts). You can also <a href="https://github.com/frasertweedale/blog-fp/commit/fe72af9144fea3ece5295ac5446f647560119088">view the commit</a> that implements this feature.</p>
<p>There’s not much else to say, really. Pandoc is still awesome. Hakyll is still awesome. And I am very happy with the results of this little enhancement. Go forth and pilcrow-ise your Hakyll sites!</p>]]></summary>
</entry>
<entry>
    <title>Migrating from QuickCheck to Hedgehog: mixed results</title>
    <link href="https://frasertweedale.github.io/blog-fp/posts/2020-03-31-quickcheck-hedgehog.html" />
    <id>https://frasertweedale.github.io/blog-fp/posts/2020-03-31-quickcheck-hedgehog.html</id>
    <published>2020-03-31T00:00:00Z</published>
    <updated>2020-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="migrating-from-quickcheck-to-hedgehog-mixed-results">Migrating from QuickCheck to Hedgehog: mixed results</h1>
<p>I’ve known about <a href="https://hackage.haskell.org/package/hedgehog">Hedgehog</a> from its early days. Having used QuickCheck before Hedgehog arrived, I am familiar with QuickCheck’s pain points, in particular the lack of automatic shrinking and the frustrations of its type class-driven approach. Hedgehog was designed to—and does—solve these problems.</p>
<p>Yet, being already a user of QuickCheck in most of my Haskell projects, I did not feel a need to make the switch. “Some day, but not today”. And finally, the day has come. In this post I will explain the catalyst and the results of the switch including a surprising and (for me) detrimental behavioural difference between QuickCheck and Hedgehog.</p>
<h2 id="background">Background <a href="#background">§</a></h2>
<p><a href="https://hackage.haskell.org/package/purebred-email"><em>purebred-email</em></a> is a comprehensive mail processing library. It has plenty of tests, example and property-based, including serialiser/parser round-trip tests. Email has a 7-bit (ASCII) wire format; there are various mechanisms for including 8-bit data in messages. For including 8-bit data in header values, <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a> defines the <code>encoded-word</code> mechanism. Serialised Unicode data in the <code>To</code> and <code>From</code> headers can look something like this:</p>
<pre><code>MIME-Version: 1.0
From: =?utf-8?B?0JDQu9C40YHQsA==?= &lt;alice@example.com&gt;
To: =?utf-8?Q?Riob=C3=A1rd_Baker?= &lt;bob@example.net&gt;
Content-Transfer-Encoding: 7bit
Content-Disposition: inline
Content-Type: text/plain; charset=us-ascii

Hello, Bob!</code></pre>
<p>Recently someone filed an <a href="https://github.com/purebred-mua/purebred-email/issues/50">issue</a> that <em>purebred-email</em> was not encoding the display name part of email addresses properly. It was indeed the case that raw UTF-8 data was appearing in the rendered message. Alongside a candidate fix I took the opportunity to add a round-trip QuickCheck property that would test serialisation and re-parsing of an email address with arbitrary mailboxes in the <code>From</code> header. The display name part of the mailbox could include Unicode characters. The property, and some related generators, were defined as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">prop_messageRoundTrip ::</span> <span class="dt">Property</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>prop_messageRoundTrip <span class="ot">=</span> forAll genMailbox <span class="op">$</span> \mailbox <span class="ot">-&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="kw">let</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    l <span class="ot">=</span> headerFrom defaultCharsets</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    msg <span class="ot">=</span> set l [mailbox] (createTextPlainMessage <span class="st">&quot;Hello&quot;</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="kw">in</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    (view l <span class="op">&lt;$&gt;</span> parse (message mime) (renderMessage msg))</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>    <span class="op">==</span> <span class="dt">Right</span> [mailbox]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="ot">genDomain ::</span> <span class="dt">Gen</span> <span class="dt">Domain</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>genDomain <span class="ot">=</span> <span class="dt">DomainDotAtom</span> <span class="op">&lt;$&gt;</span> genDotAtom</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="ot">genDotAtom ::</span> <span class="dt">Gen</span> (<span class="dt">NonEmpty</span> <span class="dt">B.ByteString</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>genDotAtom <span class="ot">=</span> fromList <span class="op">&lt;$&gt;</span> listOf1 fragment</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>  fragment <span class="ot">=</span> B.pack <span class="op">&lt;$&gt;</span> listOf1 atext</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>  atext <span class="ot">=</span> arbitrary <span class="ot">`suchThat`</span> isAtext</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a><span class="ot">genLocalPart ::</span> <span class="dt">Gen</span> <span class="dt">B.ByteString</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>genLocalPart <span class="ot">=</span> fold <span class="op">.</span> intersperse <span class="st">&quot;.&quot;</span> <span class="op">&lt;$&gt;</span> genDotAtom</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a><span class="ot">genAddrSpec ::</span> <span class="dt">Gen</span> <span class="dt">AddrSpec</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>genAddrSpec <span class="ot">=</span> <span class="dt">AddrSpec</span> <span class="op">&lt;$&gt;</span> genLocalPart <span class="op">&lt;*&gt;</span> genDomain</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a><span class="ot">genMailbox ::</span> <span class="dt">Gen</span> <span class="dt">Mailbox</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>genMailbox <span class="ot">=</span> <span class="dt">Mailbox</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> genAddrSpec</span></code></pre></div>
<p>Note that I explicitly define and directly use the generators. Defining <code>Arbitrary</code> instances for these types was too restrictive. I also felt it would be difficult to implement accurate and useful shrinking heuristics for these domain objects.</p>
<p>And this is where the fun began.</p>
<h2 id="from-quickcheck-to-hedgehog">From QuickCheck to Hedgehog <a href="#from-quickcheck-to-hedgehog">§</a></h2>
<p>By default, QuickCheck checks properties 100 times with random inputs. I had a hunch that for this property, 100 was not enough, so I overrode the default to check <code>prop_messageRoundTrip</code> 10,000 times. And hey, what do you know, QuickCheck found a bug:</p>
<pre><code>    message round trip with From header:        FAIL (3.89s)
      *** Failed! Falsified (after 1090 tests):
      Mailbox (Just &quot;\r\n\617309\990252F\SO{\36170\EOTE\rjxHg\NUL\375521\40710\878394\812276%\273790\USU2
\NAK\DC1\FS=K#\SO\SYNAIA\37830\617194jP\201749\1025883cV3\98741\RS\\=\r5H&#39;^o\109453\925605\247522&lt;\775764
\1029678I%\\.{e\1108491R9MT\942184KJ\EOTj\1080860\SOwB\162509\ENQ&quot;) (AddrSpec &quot;Ad+j3dRo21+%_fQ|_^1SnUQhwq
p7z2zimd}{|KaGI#F^4kIk9jO.%C6SUZ=$vNfiprz|O4j.bE1rAcfFP&amp;9/C3L.OT-QDI=De5kF$qD=4dfNa`ReRBSX`J-PB}xaYIbEoCm
IMsE{}.tvrjkuw=6=--dX|33Y/v+~kNbhGguS.xCM7bX2+|kH=lvRY3Z#QyGUb++ZvMI66e^3/yMM`K30Lud_kGnm`4cfdKv.VGLCF#.{
!uVXd*|KI&amp;A2oEa2awZ6oIrAUckzM9%qgz}A|1O9Sd~WdJ*plt?3$OI=WmU7B`.hlpz1&#39;|6JtBuYoCpWwsL7m+d7vX?xDOSjbr/0FOxr|
2N?p$nQ**P*R6pj2HfubS6VW-lap33WI^.MPYiQcw3SUfKVo0eU~zX3W#xCG4fxV~sswK&amp;O2E9.0NXG_4zOJyWvv=-7`2e*jydY=sQeET
h9=_~ypqW9D.xarK{XeP`#9gUJ2O!Jg7pb$t037mO3rjAwDKxs/VZZy}1{3NIzzuyl!cF~sCQAzS---6HtLvmEgYhWjijVH.Svl`sV#-y
/}B8gUFK&#39;l?Bnoj^pU-MI.Vrw{WFXLbZ09GW!cdtPObmhz}?v8xzz+LR`U?cBP!zuI=iRTK}_m#9PGJNH6WZcn3u4td-8y{rj_r^DKY{q
K*w+kK.%x.cLIek|fzQ9dJLpaVI|fJx{!-~sFO-}Q_?7F#-naFR4s7#7=Y_U-%HXhKsK1qJC.{P3*F7==MCX6sGU^q5sh9M*L0fFF9knT
h^A6ZAXYLS$BX}/31sU|}+Q!cdj#hGFRqcjp~IoHw|JGKK}/6Y?E%+cop.*&amp;`rJM87aH!Nph&amp;6pMU-U+Z3o-7L.HAoHW#-vfadyy+AA?O
9LI2hU5xfkGAwz/T-7$Wr=&#39;x7-&#39;+}AZ6yUGB.!&amp;nq7`ViGdFM#Er0}yJtWFRi#/zNMf!_gtBitQH{=G}PefcLcPF^%S3K6qqsl.?NqTE0
e&amp;$%GHS.7AGCSviyx*-Bq|hA6+&#39;!#{foj!$i.7evxp3cwoST#Bbz4CmJeAyUHMqsgnbW&amp;fG08gOoBqBIuda#$q}G3e1G8f!b5w^_A}C.!
=HPqzE1.4enC.QrCTo*~PE%`}5Q-/PPNXw|3!%^*s$YaFdvjPVegSJ4vuJAa6o{A-5pfW#-IT1}r?dw&#39;y.`SzR&amp;X#G%zFF%d%/wWS1cyZ
f%WXox_j^qew1?4P!uBqb&amp;&amp;XxoLk*d*gOg-Uh/WG~#3Zqq`ZSw#}Cu&#39;2&amp;JK.83YmO!v0g$bNSixtQpV!-##0VHRC#flu~_`.*w^/HWm7s
oMfEy^Sh082g3*R!vlPFCWZ7wk%J}GLxZcNut!%8p?+Y|A9}&#39;Za5-{kkGMMH|G%dRcbL|.IQDP1VzCY&#39;p&#39;h+~{`|_Aba*Fl5ccRJhWyGC
T._4#I%7TXR0FOH0+T%u67Per++r?kePkhWExZ6co{i#oBkZ6U&amp;XHbrxV5Xy{#Dk#0|%0CgWy*{8t*+.&amp;|}?/*i/Zp{LYJgWISJNqNkKx
nZtPo04/MTH&#39;.$R7ck6kvg2&amp;vsCwqPLo`H%E*y$7`sw~9d*#53M4%KKw|qlN1h`*P2#&amp;=6U{exw^&#39;I^|?/`=-WOip/Cn{5`h&#39;1X.l3B^N
G?UP6lbO-%Dh7.|obTf3fH252SHx62hpeM8*Va}2Gv+5z`Pnun?EDL.Wx-EkiTsfsc05E3X`%WAtO3mgoc$TfFrX&#39;JsSa_+k$/Hw8Mou=
hh^7B2206}PSj%~W966_-VB.4w2.khd0&#39;i^3Ie!#u%Lo0U54HctD1eJdHR2q.mZKa6b$|UT26dz$|eMg}$Qo+k`ron_nT~#32L9`P8y7.
ft7tN{Lf}S&amp;85#|32O6IJA3jE4gCz=ZN^1&amp;Z9uDaUl|KJ3jGPHD.R~c~v!-rXY$Dx{MsJ&#39;f~gz&amp;4*UgWe|aO=8BQZF$gk_U1W_oy/TVJ2
C9W%.Y%#hgwGxU?-g&amp;PhoG+RfflLU-ad-m-%/`m+n-c+^/8^9kj&amp;dG={0+bgkw0xrJh{PF1cKkWbN&amp;.k1jtJXaqp442SHMenuYf2&amp;R3VV
~~{Q}.iPFaih}fhC6yP%^&#39;+AugNXl?jh*pLJb+U_0pz3+`QP3w9SS!EnH!0m`NZzbQ4%Moa.N}qMwRJnb#L{BE2d?+*-rmdL!YnV7E^EO
tbQS~dmT5AVEOeHhz8*IchVaLl{Xvdubm0&amp;XYO6GSzH|gO%#wO~Kl{h.AZ2N#$r&amp;wKk-msV8ybJ9$LQ.*2=u+0pws3+8bdFdJJ&amp;E/%Qa=
BmN?rl~QZfxQq~|Vz*#s_ZTs4Kp^%2{0!cJOSI9|Dk.WL%H0pRgY.Ht?h{Xz3L!A^-AIcT{=U+YNssZnaJ%%=}8Ylp6zO.3L5SNnB&amp;6G+
b`6{e#p5565M4WDriUH4!IByU?US{TkQf5c8WP3}XirW1RJDT~-e=u!v4mj63QBaYYr6.rx*NJ8olK+Xu3Z4&amp;YI8C2?x_6`.M%6G.TX!U
n0VOsNM8~Bss8XKA|.i9k}99EeOx%JqIXc+{u.Gu9Ns=d1}HasDj^IzFDSa5$SzeK.4hwf#a1Fcewp_PXOC-VKJuKz.8mG+Kjy4Pgxwm4
`rv5lP%8{jEfjhsj9t$zsp4mb85J_ZyXbyFgWo2t1RT&#39;-ReGCSh.ypHp!C/3UiFGJ_/#A|YSL?{#5b~`U0Y$xVvh9taFi#&#39;NJcIy5H&#39;3D
*I.?KJ9ngID*l2M.Cg`*~yCdu{pXYG**8slMmHXA.zgw.9v-jzj&#39;xti{E|+Pg~nT+b+w6BkJTx53|^Q6U^Ll#.COxJYvKowVc3Oy_l!6^
2&#39;4YtmFZHYL-e1U|e2c+aAMJTFNKbeEUMfCpjEX%$$?oS}^.9F33J$_1ALwi*+MNU&amp;qvsLQ/WI^UnCd4+.Z/%xt.fMCbDzRJcZFN#=Qvi
_C6Z|4LCf&amp;0a4iM-Dg^|&amp;YVr8wIfV0z$.1gQXg3__l2%ir-vXIQ{0pf}k!Ejx+#L|j_X6DBTit`s{2.Cx2d63gz&amp;9IdkD6klHwx_{vKCu
D9{}Pb7GvTqL4c6sAJ&#39;H&#39;XaxJa8-3.-WAewPr0h.|SwcuIFliH5-Ro8zigOb=92^ZR%aM8B5I$wbNrU}XB4#dYYAIlBP1Cx~?Fw7BqIV_
ri^.z_znwUBWdhYK7^JYG0$F#Bk-rc%rfy*XiazKA2OuMs.k&quot; (DomainDotAtom (&quot;Ut||VyF|OIoq`9h`6!`_nL|s+b5OLb}VM!Qe&#39;+
1&quot; :| [&quot;UtT9C?7!stiF&amp;i&quot;,&quot;u&quot;,&quot;52IO&#39;0S9wrvodlpL`}M^N#K|6Hliu!hd`sk7t&amp;wwD0S%H#ZWcvIf+ZCn{C$4Q38NZ/{hn2GdL0/l
ZExv&quot;,&quot;wP{kH9SF2v?hH`81GI{aJyGmje3d1o`DRS4r4&#39;rMzXs&quot;])))
      Use --quickcheck-replay=822386 to reproduce.</code></pre>
<p>Without shrinking, the counterexample was a wall of text. It was good to know that there was a problem, but I didn’t even attempt to make any sense of it. I knew that this was the moment. It was time to unleash the Hedgehog.</p>
<p>Switching to Hedgehog was a simple mechanical translation. The updated definitions follow.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">prop_messageRoundTrip ::</span> <span class="dt">Property</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>prop_messageRoundTrip <span class="ot">=</span> property <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  from <span class="ot">&lt;-</span> forAll genMailbox</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  <span class="kw">let</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    l <span class="ot">=</span> headerFrom defaultCharsets</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    msg <span class="ot">=</span> set l [from] (createTextPlainMessage <span class="st">&quot;Hello&quot;</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  (view l <span class="op">&lt;$&gt;</span> parse (message mime) (renderMessage msg))</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    <span class="op">===</span> <span class="dt">Right</span> [from]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="ot">genDomain ::</span> <span class="dt">Gen</span> <span class="dt">Domain</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>genDomain <span class="ot">=</span> <span class="dt">DomainDotAtom</span> <span class="op">&lt;$&gt;</span> genDotAtom</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="ot">genDotAtom ::</span> <span class="dt">Gen</span> (<span class="dt">NonEmpty</span> <span class="dt">B.ByteString</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>genDotAtom <span class="ot">=</span> Gen.nonEmpty (Range.linear <span class="dv">1</span> <span class="dv">5</span>) fragment</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>  fragment <span class="ot">=</span> Gen.utf8 (Range.linear <span class="dv">1</span> <span class="dv">20</span>) atext</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>  atext <span class="ot">=</span> Gen.filter isAtext Gen.ascii</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span class="ot">genLocalPart ::</span> <span class="dt">Gen</span> <span class="dt">B.ByteString</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>genLocalPart <span class="ot">=</span> fold <span class="op">.</span> intersperse <span class="st">&quot;.&quot;</span> <span class="op">&lt;$&gt;</span> genDotAtom</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a><span class="ot">genAddrSpec ::</span> <span class="dt">Gen</span> <span class="dt">AddrSpec</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>genAddrSpec <span class="ot">=</span> <span class="dt">AddrSpec</span> <span class="op">&lt;$&gt;</span> genLocalPart <span class="op">&lt;*&gt;</span> genDomain</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a><span class="ot">genMailbox ::</span> <span class="dt">Gen</span> <span class="dt">Mailbox</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>genMailbox <span class="ot">=</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>  <span class="dt">Mailbox</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>  <span class="op">&lt;$&gt;</span> Gen.maybe (Gen.text (Range.linear <span class="dv">0</span> <span class="dv">100</span>) Gen.unicode)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a>  <span class="op">&lt;*&gt;</span> genAddrSpec</span></code></pre></div>
<p>As you can see there are no structural changes. Indeed, several of the definitions did not change at all (except that the name <code>Gen</code> now refers to a different type).</p>
<p>I ran the tests again, expecting Hedgehog to find the bug and, thanks to integrated shrinking, present me with a digestable counterexample. But the tests passed. Even after 10,000 iterations it could not detect the bug:</p>
<pre><code>message round trip with From header:             OK (4.75s)
  ✓ message round trip with From header passed 10000 tests.</code></pre>
<h2 id="generator-bias">Generator bias <a href="#generator-bias">§</a></h2>
<p>Hedgehog’s inability to find a counterexample surprised me, and several other people in <code>#bfpg</code>. The search for answers soon led me to the source code, where all was laid bare. Hedgehog’s <code>Gen.unicode</code> has a uniform distribution over all Unicode characters:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">-- | Generates a Unicode character, excluding noncharacters</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="co">--   and invalid standalone surrogates:</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co">--   @&#39;\0&#39;..&#39;\1114111&#39; (excluding &#39;\55296&#39;..&#39;\57343&#39;,</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co">--    &#39;\65534&#39;, &#39;\65535&#39;)@</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="co">--</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="ot">unicode ::</span> (<span class="dt">MonadGen</span> m) <span class="ot">=&gt;</span> m <span class="dt">Char</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>unicode <span class="ot">=</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  <span class="kw">let</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    s1 <span class="ot">=</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>      (<span class="dv">55296</span>, enum <span class="ch">&#39;\0&#39;</span> <span class="ch">&#39;\55295&#39;</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    s2 <span class="ot">=</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>      (<span class="dv">8190</span>, enum <span class="ch">&#39;\57344&#39;</span> <span class="ch">&#39;\65533&#39;</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    s3 <span class="ot">=</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>      (<span class="dv">1048576</span>, enum <span class="ch">&#39;\65536&#39;</span> <span class="ch">&#39;\1114111&#39;</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>  <span class="kw">in</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>    frequency [s1, s2, s3]</span></code></pre></div>
<p>Whereas QuickCheck’s <code>Char</code> generator, although it can generate any Unicode character, has a heavy bias to the ASCII codepoints (0–127):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  arbitrary <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    frequency</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>      [(<span class="dv">3</span>, arbitraryASCIIChar),</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>       (<span class="dv">1</span>, arbitraryUnicodeChar)]</span></code></pre></div>
<p>After discovering this difference I implemented an equivalent Hedgehog generator to use instead of <code>Gen.unicode</code>, and updated <code>genMailbox</code> to use it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">unicodeCharAsciiBias ::</span> <span class="dt">Gen</span> <span class="dt">Char</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>unicodeCharAsciiBias <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  Gen.frequency [(<span class="dv">3</span>, Gen.ascii), (<span class="dv">1</span>, Gen.unicode)]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="ot">genMailbox ::</span> <span class="dt">Gen</span> <span class="dt">Mailbox</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>genMailbox <span class="ot">=</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  <span class="dt">Mailbox</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  <span class="op">&lt;$&gt;</span> Gen.maybe (Gen.text (Range.linear <span class="dv">0</span> <span class="dv">100</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>                 unicodeCharAsciiBias)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  <span class="op">&lt;*&gt;</span> genAddrSpec</span></code></pre></div>
<h2 id="shrink-to-win">Shrink to win <a href="#shrink-to-win">§</a></h2>
<p>This time Hedgehog found the counterexample. The automatic shrinking produced a minimal counterexample and Hedgehog presented its findings:</p>
<pre><code>message round trip with From header:                  FAIL (47.81s)
 ✗ message round trip with From header failed at tests/Message.hs:106:3
   after 866 tests and 69 shrinks.

       ┏━━ tests/Message.hs ━━━
   100 ┃ prop_messageRoundTrip :: Property
   101 ┃ prop_messageRoundTrip = property $ do
   102 ┃   from &lt;- forAll genMailbox
       ┃   │ Mailbox (Just &quot;\r\n&quot;) (AddrSpec &quot;!&quot; (DomainDotAtom (&quot;!&quot; :| [])))
   103 ┃   let
   104 ┃     l = headerFrom defaultCharsets
   105 ┃     msg = set l [from] (createTextPlainMessage &quot;Hello&quot;)
   106 ┃   (view l &lt;$&gt; parse (message mime) (renderMessage msg)) === Right [from]
       ┃   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
       ┃   │ ━━━ Failed (- lhs) (+ rhs) ━━━
       ┃   │   Right [
       ┃   │       Mailbox
       ┃   │ -       Just &quot;=?us-ascii?Q? ?=&quot;
       ┃   │ +       Just &quot;\r\n&quot;
       ┃   │         AddrSpec &quot;!&quot; (DomainDotAtom (&quot;!&quot; :| []))
       ┃   │     ]</code></pre>
<p>Isn’t the presentation—that neatly formatted diff of the data structure—just <em>gorgeous</em>?! It is easy to see the problem: <em>purebred-email</em> did not round-trip an email address correctly when then display name was (perhaps more generally, <em>contained</em>) a carriage return followed by a newline/line feed (CRLF). <code>"\r\n" !@!</code> is a pretty bonkers email address but the types and grammar do permit it so <em>purebred-email</em> must handle it correctly.</p>
<h2 id="probabilities">Probabilities <a href="#probabilities">§</a></h2>
<p>So now we can see why QuickCheck was able to find a counterexample and Hedgehog (when using <code>Gen.unicode</code>) was not. It is a matter of probability distribution. The probability of selecting CR followed by LF from a uniform distribution of all 1112062 unicode characters is 1 in 1236681891844, whereas for the 75% ASCII distribution (noting that the other 25% for all Unicode characters <em>also</em> includes the ASCII codepoints) is 2782747776649 over 81047184463888384 or roughly 0.0000433491.</p>
<p>Note that 0.0000433491 is a bit less than half of 1 in 10000. We expect then that if we were executing 10000 tests, the framework would find this counterexample less than half the time. But this probability is for two-character sequences. The probability of a CRLF subsequence occuring in a longer string of randomly selected characters is, intuitively, much greater. But my probability-fu is not strong enough to work all that out. As it happens, with the ASCII-biased distribution both QuickCheck and Hedgehog usually find the counterexample somewhere around the 1000th test (but sometimes much sooner).</p>
<h2 id="shrinking-performance">Shrinking performance <a href="#shrinking-performance">§</a></h2>
<p>Automatic shrinking is a joy. But Hedgehog’s shrinking is slow compared to QuickCheck. In the example above, it took almost a whole minute, most of which was the shrinking (compare with the earlier <code>Gen.unicode</code> example which tested the property 10,000 times in 4.7 seconds).</p>
<p>I don’t see this has a problem: if it takes a long time to find a minimal counterexample, so be it. The tradeoff is worth it. And it is only the shrinking that is slow. If your tests are passing (and hopefully they do, most of the time) then there is no penalty.</p>
<p>While I was discussing these things, one person shared with me that Hedgehog ate all their memory during shrinking, and crashed. So the slowness might be due to space usage (at least in part). I didn’t experience any crashes (yet) but it was prudent to share this anecdote. Your mileage may vary.</p>
<h2 id="conclusion">Conclusion <a href="#conclusion">§</a></h2>
<p>Hedgehog is great. It solves the major pain points of QuickCheck. Automated shrinking for all generators is a killer feature, but it is computationally (and/or space) expensive, and might eat all your memory and crash (I have not experienced this myself). The pretty output with a nicely formatted diff of the data structure makes it easier to comprehend the counterexamples than QuickCheck’s <code>Show</code>-based output.</p>
<p>Converting from QuickCheck to Hedgehog is a breeze; a simple mechanical translation. But <strong>do not blindly convert</strong>. I would probably never have found this bug if I had already converted <em>purebred-email</em> to Hedgehog, because of a critical difference in the distribution of one of the generators. When you are converting, pay careful attention to the behaviour of the generators, especially if they produce character or string types.</p>
<p>The issue I experienced comes down to a lack of documentation. Arguably QuickCheck is the bad guy in this tale: the non-uniform distribution should have been documented. But it would be good for <em>all</em> generators or <code>Arbitrary</code> instances to say something about their distribution, even if it’s just <em>“uniform distribution”</em>.</p>
<p>I always intended to start using Hedgehog, and expected that it would be a gradual transition. At time of writing, QuickCheck and Hedgehog are happily coexisting in the <em>purebred-email</em> test suite. From now on any new test modules I write will probably use Hedgehog, and older modules will be converted any time I bump against QuickCheck’s shrinking or type class-related rough edges.</p>]]></summary>
</entry>

</feed>
