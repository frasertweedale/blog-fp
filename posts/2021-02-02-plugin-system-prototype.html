<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>pureblog - Prototyping a plugin system for Purebred</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Prototyping a plugin system for Purebred","datePublished":"2021-02-02T00:00:00"}</script>
        <meta property="og:type" content="article" /><meta property="og:url" content="https://frasertweedale.github.io/blog-fp/posts/2021-02-02-plugin-system-prototype.html" /><meta property="og:title" content="Prototyping a plugin system for Purebred" /><meta property="og:description" content="In this post I present an experimental design for a plugin system, where plugins’ capabilities are expressed in their types. The types are user-visible and human-friendly. This is achieved without sacrificing composability—plugins with different capabilities can be composed together." /><meta property="og:image" content="https://frase.id.au/photo_crikey_large.jpg" />
        <meta name="twitter:card" content="summary" /><meta property="twitter:creator" content="@hackuador" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">pureblog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div class="info">
    
    Tags: <a title="All pages tagged 'plugins'." href="../tags/plugins.html">plugins</a>
    
</div>

<div id="postContent">
    <h1 id="prototyping-a-plugin-system-for-purebred">Prototyping a plugin system for Purebred</h1>
<p>In this post I present an experimental design for a plugin system, where plugins’ capabilities are expressed in their types. The types are user-visible and human-friendly. This is achieved without sacrificing composability—plugins with different capabilities can be composed together.</p>
<h2 id="introduction">Introduction <a href="#introduction" class="section">§</a></h2>
<p>I’m working on a plugin system for <a href="https://github.com/purebred-mua/purebred">Purebred</a>, a mail user agent program. The goal of every plugin system is to enable smooth integration (composition) of components from various packages into the main program, providing additional or alternative behaviour.</p>
<p>My secondary goal for <em>this</em> plugin system is to express as much information as possible about plugin behaviour <em>through types</em>. A plugin that purports to perform a pure computation (e.g. adding a <code>User-Agent</code> header to outgoing mail) should not be allowed to launch the missiles! Its type should express this constraint. Doing so communicates important information to the compiler (which enforces the constraints), and to humans (who will ask questions like, <em>“How safe is this plugin?”</em>)</p>
<p>Haskell provides for substantial and satisfying progress toward this objective, without compromising the primary goal of composition. After experimenting with several different approaches I arrived at the design that I am presenting here in this post. I will begin with a description of the <a href="#test-bed-program">test-bed program</a>, then outline my <a href="#plugin-system-requirements">requirements</a> for a plugin system. Then I describe the <a href="#solution">solution</a>, and conclude with a <a href="#discussion">discussion</a> of design tradeoffs and considerations for implementing this design in Purebred.</p>
<h2 id="test-bed-program">Test-bed program <a href="#test-bed-program" class="section">§</a></h2>
<p>I wrote a small, simple program to serve as the test-bed for plugin system experimentation. This program reads a <code>Bool</code> and an <code>Int</code> from user input, negates the number if the <code>Bool</code> is <code>True</code>, and prints the result.</p>
<p><code>Main.hs</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (hFlush, stdout)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- read start values</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  doNegate <span class="ot">&lt;-</span> prompt <span class="st">&quot;negate number? [True|False]&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> prompt <span class="st">&quot;number (Int)&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  (j, doNegate') <span class="ot">&lt;-</span> <span class="fu">flip</span> runStateT doNegate <span class="op">$</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> i  <span class="co">-- </span><span class="al">TODO</span><span class="co"> run plugins</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- print result</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> r <span class="ot">=</span> <span class="kw">if</span> doNegate' <span class="kw">then</span> <span class="fu">negate</span> j <span class="kw">else</span> j</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStr</span> <span class="st">&quot;result: &quot;</span> <span class="op">*&gt;</span> <span class="fu">print</span> r</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  prompt s <span class="ot">=</span> <span class="fu">putStr</span> (s <span class="op">&lt;&gt;</span> <span class="st">&quot;: &quot;</span>) <span class="op">*&gt;</span> hFlush stdout <span class="op">*&gt;</span> <span class="fu">readLn</span></span></code></pre></div>
<p>Running the program, telling it to negate the input and giving it the value <code>10</code>, gives the following transcript:</p>
<pre><code>ftweedal% ./Main
negate number? [True|False]: True
number (Int): 10
result: -10</code></pre>
<p>I put a <code>TODO</code> where I want to execute plugin behaviour, in a <code>StateT Bool IO Int</code> computation. Plugins should be able to manipulate the <code>Int</code> <em>result</em> value, and/or read or modify the <code>Bool</code> <em>state</em> value, and/or perform I/O.</p>
<h2 id="plugin-system-requirements">Plugin system requirements <a href="#plugin-system-requirements" class="section">§</a></h2>
<p>The requirements for my plugin system are:</p>
<ul>
<li><p><strong>Composition</strong>: Plugins from different modules or packages must be able to be used together in the main program.</p></li>
<li><p><strong>Capabilities</strong>: Plugins modules must express required capabilities in their exported type(s). That is, the capabilities are visible to users, without reading source code.</p></li>
<li><p><strong>Human-friendly</strong>: The plugin system must be comprehensible to end-users, who are not necessarily programmers.</p></li>
<li><p><strong>Configuration</strong>: Some plugins will need user-specified configuration. Static configuration (i.e. no change after program initialisation) is acceptable.</p></li>
<li><p><strong>Abstract</strong>: Plugin behaviour types must not mention the type of the main program’s monad transformer stack. This allows the main program’s implementation to evolve without breaking the plugin API.</p></li>
</ul>
<h3 id="not-in-scope">Not in scope <a href="#not-in-scope" class="section">§</a></h3>
<p>There are some other points in the plugin system design space that I am not trying to solve:</p>
<ul>
<li><p><strong>Plugin loading</strong>: How does the program find and load plugins? In my experimental design, the plugins will be statically compiled into the program. This approach will also work for Purebred, because we use <a href="https://hackage.haskell.org/package/dyre"><em>Dyre</em></a> for configuration by recompilation (in the style of <a href="https://xmonad.org/"><em>xmonad</em></a>). Dynamic loading/unloading/reloading of plugins is an interesting topic, but I’m not trying to solve it here. The <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.128.6930&amp;rep=rep1&amp;type=pdf"><em>Plugging Haskell In</em></a> paper (Chakravarty <em>et al</em>) and <a href="https://hackage.haskell.org/package/plugins"><em>plugins</em> library</a> present one solution to the problem.</p></li>
<li><p><strong>Plugin state</strong>: What if a plugin needs to store/retrieve data <em>related to itself</em> in the program state? Plugins have no control over the state data type of the main program. I don’t see a need for this in Purebred (yet), so I’m not going to tackle this problem. But if I were, I would look at <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Dynamic.html"><code>Data.Dynamic</code></a> and <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-IORef.html"><code>Data.IORef</code></a> as possible starting points.</p></li>
<li><p><strong>Plugin “idempotency”</strong>: If you enable the PGP plugin twice, will it sign/encrypt the outgoing message twice? In the Purebred approach to configuration this sort of mistake is unlikely, so I’m going to ignore this problem.</p></li>
</ul>
<h2 id="solution">Solution <a href="#solution" class="section">§</a></h2>
<p>In this section I describe the implementation of the prototype plugin system. The code is also available in a <a href="https://github.com/frasertweedale/hs-plugin-system-prototype">Git repository</a>, under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a> license. You can clone, review, compile, test and experiment with the code yourself.</p>
<h3 id="language-extensions">Language extensions <a href="#language-extensions" class="section">§</a></h3>
<p>I define the plugin types and helpers in <code>Plugin.hs</code>. Some language extensions are required:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuantifiedConstraints #-}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Plugin</span> <span class="kw">where</span></span></code></pre></div>
<p>These extensions are uncontroversial. Only <code>UndecidableInstances</code> is a bit iffy, but it’s safe to use here. I shall indicate the declarations that require these extensions as we encounter them.</p>
<p><code>Main.hs</code> and the modules defining the plugins themselves do not require any language extensions.</p>
<h3 id="the-plugin-type">The <code>Plugin</code> type <a href="#the-plugin-type" class="section">§</a></h3>
<p>The test-bed program will execute plugins in the <code>StateT Bool IO</code> monad transformer stack. Each plugin takes an <code>Int</code> input and returns a (possibly modified) <code>Int</code>. The concrete type is of such a function is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Plugin</span> <span class="ot">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">Bool</span> <span class="dt">IO</span> <span class="dt">Int</span></span></code></pre></div>
<p>One of the requirements is that the plugin function type must be abstract, so that the main program’s monad transformer stack can evolve if needed. We also know that different plugins will have different constraints, and that we want to express the constraints in the type. So let’s parameterise the function type over the constraint:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Plugin</span> ctx <span class="ot">=</span> <span class="kw">forall</span> m<span class="op">.</span> (ctx m) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">Int</span></span></code></pre></div>
<p>That declaration requires the <code>RankNTypes</code> and <code>ConstraintKinds</code> language extensions. To understand <code>ConstraintKinds</code>, let’s look at the <em>kind</em> of <code>Plugin</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">Plugin</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Plugin</span><span class="ot"> ::</span> ((<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p><code>Constraint</code> is the kind of constraints (things that go before <code>=&gt;</code> in a type declaration). The <code>Plugin</code> type constructor has a single argument of kind <code>(Type -&gt; Type) -&gt; Constraint</code>. Here are some things that have that kind:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Applicative</span><span class="ot">     ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MonadIO</span><span class="ot">         ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="dt">MonadState</span> <span class="dt">Bool</span><span class="ot"> ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span></code></pre></div>
<p>So we can, for example, apply <code>Plugin</code> to <code>MonadState Bool</code>, to construct the <code>Type</code> of a plugin that can read and write the program state:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Plugin</span> (<span class="dt">MonadState</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Type</span></span></code></pre></div>
<p>Defining plugins this way has satisfied the <strong>capabilities</strong> and <strong>abstract</strong> requirements. The capabilities (✓) are visible in the type as abstract type class (✓) constraints.</p>
<p>In a real world scenario, there might be multiple parts of the main program to hook into. It is also useful to give a plugin a name, so that the program can express which plugins are in use, report errors, and so on. So I turned <code>Plugin</code> into a data type with a name field:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Plugin</span> ctx <span class="ot">=</span> <span class="dt">Plugin</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> pluginName ::</span> <span class="dt">String</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> pluginHook ::</span> <span class="kw">forall</span> m<span class="op">.</span> (ctx m) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">Int</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>For applications with many hooks, it would be nice to wrap the hook fields in <code>Maybe</code> (so the plugin doesn’t have to implement them all). Alternatively, I could provide a helper function that initialises the hooks to “no-op” functions. Plugins would override the hooks they use. For this experiment there is only one hook, so I’ve skipped this for now.</p>
<h3 id="capabilities">Capabilities <a href="#capabilities" class="section">§</a></h3>
<p>The plugin system could be used by non-programmers; the types have to make sense to them. What is a <code>Plugin Applicative</code>? What is a <code>Plugin (MonadState Bool)</code>?! I defined type synonyms for the various constraints, to (hopefully) make the plugin system more comprehensible to humans—programmer and non-programmer alike:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pure</span> <span class="ot">=</span> <span class="dt">Applicative</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CanIO</span> <span class="ot">=</span> <span class="dt">MonadIO</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CanRWState</span> <span class="ot">=</span> <span class="dt">MonadState</span> <span class="dt">Bool</span></span></code></pre></div>
<p>Now we can say <code>Plugin Pure</code>, or <code>Plugin CanRWState</code>. This addresses the <strong>human-friendly</strong> requirement (in part, at least).</p>
<p>What if a plugin needs to use multiple capabilities? I first approached this by defining a type synonym:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Unconstrained</span> m <span class="ot">=</span> (<span class="dt">CanIO</span> m, <span class="dt">CanRWState</span> m)</span></code></pre></div>
<p>Observe that <code>Unconstrained</code> has the required kind:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">Unconstrained</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Unconstrained</span><span class="ot"> ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span></code></pre></div>
<p>Unfortunately, we cannot use <code>Unconstrained</code> as an argument to <code>Plugin</code>, because type synonyms cannot be partially applied:</p>
<pre><code>λ&gt; :k Plugin Unconstrained

&lt;interactive&gt;:1:1: error:
    The type synonym ‘Unconstrained’ should have 1 argument,
    but has been given none</code></pre>
<p>The <a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0242-unsaturated-type-families.rst"><em>Unsaturated Type Families</em></a> proposal, when it lands, will hopefully lift this restriction. Until then, the same effect can be achieved with a type class and corresponding instance. The <code>FlexibleContexts</code>, <code>FlexibleInstances</code> and <code>UndecidableInstances</code> extensions are required for these declarations:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">CanRWState</span> m, <span class="dt">CanIO</span> m) <span class="ot">=&gt;</span> <span class="dt">Unconstrained</span> m <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- empty</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">CanRWState</span> m, <span class="dt">CanIO</span> m) <span class="ot">=&gt;</span> <span class="dt">Unconstrained</span> m <span class="kw">where</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- empty</span></span></code></pre></div>
<p>These definitions give an instance for <code>Unconstrained</code> to any type that already has instances for all the constituent capabilities. It was not necessary to mention <code>Pure</code>/<code>Applicative</code> because it is a superclass of the other constraints.</p>
<h3 id="implementing-plugins">Implementing plugins <a href="#implementing-plugins" class="section">§</a></h3>
<p>Now that I have defined the plugin type and capabilities, let’s implement some plugins.</p>
<h4 id="plugin.double"><code>Plugin.Double</code> <a href="#plugin.double" class="section">§</a></h4>
<p><code>Plugin/Double.hs</code> defines a “pure” plugin that doubles the <code>Int</code> value:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Plugin.Double</span> <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Plugin</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ot">plugin ::</span> <span class="dt">Plugin</span> <span class="dt">Pure</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>plugin <span class="ot">=</span> <span class="dt">Plugin</span> <span class="st">&quot;Double&quot;</span> <span class="op">$</span> <span class="fu">pure</span> <span class="op">.</span> (<span class="op">*</span><span class="dv">2</span>)</span></code></pre></div>
<h4 id="plugin.offset"><code>Plugin.Offset</code> <a href="#plugin.offset" class="section">§</a></h4>
<p><code>Plugin/Offset.hs</code> defines a “pure” plugin that adds a fixed offset to the <code>Int</code> value. The offset is configurable: applying <code>mkPlugin</code> to the configuration yields the plugin value. This satisfies our <strong>configuration</strong> requirement.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Plugin.Offset</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Plugin</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">mkPlugin ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Plugin</span> <span class="dt">Pure</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>mkPlugin offset <span class="ot">=</span> <span class="dt">Plugin</span> <span class="st">&quot;Offset&quot;</span> <span class="op">$</span> <span class="fu">pure</span> <span class="op">.</span> (<span class="op">+</span> offset)</span></code></pre></div>
<h4 id="plugin.flipnegate"><code>Plugin.FlipNegate</code> <a href="#plugin.flipnegate" class="section">§</a></h4>
<p><code>Plugin/FlipNegate.hs</code> defines a plugin that inverts the value of <code>doNegate</code> in the program state. Therefore it is a <code>Plugin CanRWState</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Plugin.FlipNegate</span> <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span> (modify)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Plugin</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="ot">plugin ::</span> <span class="dt">Plugin</span> <span class="dt">CanRWState</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>plugin <span class="ot">=</span> <span class="dt">Plugin</span> <span class="st">&quot;FlipNegate&quot;</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> i <span class="op">&lt;$</span> modify <span class="fu">not</span></span></code></pre></div>
<h4 id="plugin.shootlasers"><code>Plugin.ShootLasers</code> <a href="#plugin.shootlasers" class="section">§</a></h4>
<p><code>Plugin/ShootLasers.hs</code> uses <code>CanIO</code> to shoot the lasers. Watch out!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Plugin.ShootLasers</span> <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span> (liftIO)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Plugin</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="ot">plugin ::</span> <span class="dt">Plugin</span> <span class="dt">CanIO</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>plugin <span class="ot">=</span> <span class="dt">Plugin</span> <span class="st">&quot;ShootLasers&quot;</span> <span class="op">$</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  \i <span class="ot">-&gt;</span> i <span class="op">&lt;$</span> liftIO (<span class="fu">putStrLn</span> <span class="st">&quot;pew! pew!&quot;</span>)</span></code></pre></div>
<h3 id="composition">Composition <a href="#composition" class="section">§</a></h3>
<p>The main program will have a list (or some other container) of zero or more plugins. And it will execute the plugin hooks at the relevant part of the program. OK, let’s build a list of plugins in <code>Main.hs</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>plugins <span class="ot">=</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  [ Plugin.Double.plugin</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  , Plugin.Offset.mkPlugin <span class="dv">100</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> …</span></code></pre></div>
<p>So far so good! Now let’s add <code>ShootLasers</code> to the mix:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>plugins <span class="ot">=</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  [ Plugin.Double.plugin</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  , Plugin.Offset.mkPlugin <span class="dv">100</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  , Plugin.ShootLasers.plugin</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> …</span></code></pre></div>
<p>Uh oh:</p>
<pre><code>Main.hs:16:5: error:
    • Couldn't match type ‘MonadIO’ with ‘Applicative’
      Expected type: Plugin Pure
        Actual type: Plugin CanIO
    • In the expression: Plugin.ShootLasers.plugin
      In the expression:
        [Plugin.Noop.plugin, (Plugin.Double.plugin :: Plugin Pure),
         (Plugin.Offset.mkPlugin 100), Plugin.ShootLasers.plugin]
      In an equation for ‘plugins’:
          plugins
            = [Plugin.Noop.plugin, (Plugin.Double.plugin :: Plugin Pure),
               (Plugin.Offset.mkPlugin 100), ....]
   |
16 |   , Plugin.ShootLasers.plugin
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
<p><code>Applicative</code> is a superclass of <code>MonadIO</code>. Abstract types with these constraints can unify, but the concrete types <code>Plugin MonadIO</code> and <code>Plugin Applicative</code> do not unify. We cannot put them together in a list.</p>
<p>So when composing plugins, we need a way to <em>relax</em> the constraints of individual plugins to the “lowest common denominator”. That is, we have to construct a list of <code>Plugin Unconstrained</code>. Therefore we need a function to turn a <code>Plugin ctx</code> into a <code>Plugin Unconstrained</code>, provided that <code>Unconstrained</code> “encompasses” <code>ctx</code>. The <code>relax</code> function accomplishes this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>relax</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="kw">forall</span> m<span class="op">.</span> ctx' m <span class="ot">=&gt;</span> ctx m)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Plugin</span> ctx <span class="ot">-&gt;</span> <span class="dt">Plugin</span> ctx'</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>relax (<span class="dt">Plugin</span> n fs) <span class="ot">=</span> <span class="dt">Plugin</span> n fs</span></code></pre></div>
<p>Note the constraint: <code>(forall m. ctx' m =&gt; ctx m)</code>. This requires the <code>QuantifiedConstraints</code> language extension. It means that the function is defined only if <code>ctx</code> (the <em>input</em> plugin capability) is implied by <code>ctx'</code> (the <em>output</em> capability).</p>
<p>Now we can use <code>relax</code> to construct a <code>[Plugin Unconstrained]</code>, because <code>Unconstrained</code> implies all of the individual capabilities available to plugins:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plugins ::</span> [<span class="dt">Plugin</span> <span class="dt">Unconstrained</span>]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>plugins <span class="ot">=</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  [ relax Plugin.Double.plugin</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  , relax (Plugin.Offset.mkPlugin <span class="dv">100</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  , relax Plugin.FlipNegate.plugin</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  , relax Plugin.ShootLasers.plugin</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> …</span></code></pre></div>
<p>The prototype now satisfies the <strong>composition</strong> requirement.</p>
<h3 id="executing-plugins">Executing plugins <a href="#executing-plugins" class="section">§</a></h3>
<p>The final step is to update the main program to execute the plugins. Where previously we had <code>pure i</code> (and a <code>TODO</code> comment), we now have the Kleisli composition (monadic chaining via <code>(&gt;=&gt;)</code>) of the plugin hook functions, applied to <code>i</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- read start values</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  doNegate <span class="ot">&lt;-</span> prompt <span class="st">&quot;negate number? [True|False]&quot;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> prompt <span class="st">&quot;number (Int)&quot;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  (j, doNegate') <span class="ot">&lt;-</span> <span class="fu">flip</span> runStateT doNegate <span class="op">$</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">foldr</span> (<span class="op">&gt;=&gt;</span>) <span class="fu">pure</span> (<span class="fu">fmap</span> pluginHook plugins) i</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- print result</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> r <span class="ot">=</span> <span class="kw">if</span> doNegate' <span class="kw">then</span> <span class="fu">negate</span> j <span class="kw">else</span> j</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStr</span> <span class="st">&quot;result: &quot;</span> <span class="op">*&gt;</span> <span class="fu">print</span> r</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  prompt s <span class="ot">=</span> <span class="fu">putStr</span> (s <span class="op">&lt;&gt;</span> <span class="st">&quot;: &quot;</span>) <span class="op">*&gt;</span> hFlush stdout <span class="op">*&gt;</span> <span class="fu">readLn</span></span></code></pre></div>
<p>This time running the program, telling it to negate the input and giving it the value <code>10</code>, gives the following transcript:</p>
<pre><code>ftweedal% ./Main
negate number? [True|False]: True
number (Int): 10
pew! pew!
result: 120</code></pre>
<p>We can see that:</p>
<ul>
<li><code>Double</code> doubled the input to <code>20</code></li>
<li><code>Offset</code> added the configured offset of 100, giving <code>120</code></li>
<li><code>FlipNegate</code> turned negation off</li>
<li><code>ShootLasers</code> shot the lasers (hopefully they were not pointed at your foot)</li>
</ul>
<p>As a result, the final output of the program was <code>120</code>. Note that the order of plugins is significant. Plugins appearing earlier in the list are executed earlier.</p>
<h2 id="discussion">Discussion <a href="#discussion" class="section">§</a></h2>
<h3 id="paranoia">Paranoia <a href="#paranoia" class="section">§</a></h3>
<p>It’s all good and well that plugins express their types. But what’s to stop a <code>Plugin Pure</code> sneakily evolving into a <code>Plugin CanIO</code> upon a new release, and compromising your system?</p>
<p>The paranoid user can mitigate this risk by providing explicit type signatures for each plugin installed in the main program:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plugins ::</span> [<span class="dt">Plugin</span> <span class="dt">Unconstrained</span>]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>plugins <span class="ot">=</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  [ relax (Plugin.Double.plugin<span class="ot"> ::</span> <span class="dt">Plugin</span> <span class="dt">Pure</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  , relax (Plugin.Offset.mkPlugin <span class="dv">100</span><span class="ot"> ::</span> <span class="dt">Plugin</span> <span class="dt">Pure</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  , relax (Plugin.FlipNegate.plugin<span class="ot"> ::</span> <span class="dt">Plugin</span> <span class="dt">CanRWState</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  , relax (Plugin.ShootLasers.plugin<span class="ot"> ::</span> <span class="dt">Plugin</span> <span class="dt">CanIO</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>If any plugin releases a new version that require additional (or fewer) capabilities its type will change, resulting in a type error. For example, if <code>Double</code> becomes a <code>Plugin CanIO</code>, GHC gives the following type error:</p>
<pre><code>Main.hs:14:12: error:
    • Couldn't match type ‘MonadIO’ with ‘Applicative’
      Expected type: Plugin Pure
        Actual type: Plugin CanIO
    • In the first argument of ‘relax’, namely
        ‘(Plugin.Double.plugin :: Plugin Pure)’
      In the expression: relax (Plugin.Double.plugin :: Plugin Pure)
      In the expression:
        [relax (Plugin.Noop.plugin :: Plugin Pure),
         relax (Plugin.Double.plugin :: Plugin Pure),
         relax (Plugin.Offset.mkPlugin 100 :: Plugin Pure),
         relax (Plugin.FlipNegate.plugin :: Plugin CanRWState), ....]
   |
14 |   , relax (Plugin.Double.plugin :: Plugin Pure)
   |            ^^^^^^^^^^^^^^^^^^^^</code></pre>
<p>Thanks to the constraint type synonyms, the type error is (in my opinion) understandable. Perhaps even non-programmers could make sense of it. Unfortunately, it doesn’t hint at what a user should do to solve it. A better error message would suggest to use <code>relax</code> or to review the plugin’s type. GHC has some support for <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-TypeLits.html#g:4">user-defined type errors</a>, but at this time it is not possible to augment ordinary type mismatch errors.</p>
<h3 id="multiple-hook-functions">Multiple hook functions <a href="#multiple-hook-functions" class="section">§</a></h3>
<p>In real world applications, there can be multiple kinds of plugin functions relating to different behaviours in the main program. For example, Purebred will have a hook for processing a message prior to displaying it, and another hook for manipulating outgoing emails. Some plugins will only use a single hook, but others will use multiple hooks. For example, an OpenPGP plugin would perform decryption and signature verification when preparing a message for display, and perform signing and/or encryption when sending mail.</p>
<p>It is possible that a plugin might require different capabilities for different hooks. This poses a complex design question, with several possible solutions:</p>
<ul>
<li><p>Should all hooks have their design constraints expressed <em>separately</em> at the type level? For example, a plugin type with two hook functions could be written as <code>Plugin ctx1 ctx2</code>. The main problem with this is that adding new hooks to the plugin type is an API-breaking change. It also isn’t particularly human-friendly because the type doesn’t reveal which operation each constraint applies to.</p></li>
<li><p>Should different hooks have different types? Instead of a unified <code>Plugin</code> type, for Purebred we could have a <code>SendHook</code> and <code>DisplayHook</code>. The downside is that installing a plugin that uses multiple hooks means installing all those hooks separately. If the plugin evolves to use more (or fewer) hooks, the user has to do extra work to migrate.</p></li>
<li><p>Should plugins be a single data type, with a single constraint? The downside to this approach is the type does not express which hooks are used, or what the per-hook required capabilities are. The plugin’s single capability constraint is the union of all capabilities required by all hook functions.</p></li>
</ul>
<p>I chose the last approach, for a few reasons. First, when it comes to I/O in particular, if you are trusting <em>any</em> part of the plugin with <code>CanIO</code>, from a risk perspective it doesn’t matter much that <em>other</em> parts cannot perform I/O. Second, I suspect that plugins that use multiple hooks <em>and</em> use different capabilities for those hooks will be uncommon. For me, prioritising API stability and ease of use made the choice easy. But it is still worthwhile to discuss the tradeoffs and alternatives.</p>
<h3 id="implementation-considerations">Implementation considerations <a href="#implementation-considerations" class="section">§</a></h3>
<p>Some implementation considerations that arise when applying this plugin system design in Purebred (real-world programs in general) include:</p>
<ul>
<li><p>Plugins have to be be stored in the internal configuration object. Should the hook functions be decomposed early (storing multiple lists of hook functions in the config) or just-in-time (storing a single list of plugins, and extracting the relevant hook functions when they are needed)? I will initially store a single list of plugins.</p></li>
<li><p>It would be nice to provide information about which plugins are installed alongside version info (<code>--version</code>), “about” UI, etc.</p></li>
<li><p>Some standard functionality could be implemented using the plugin system. So, should it be? And should “wired-in” plugins be advertised or hidden?</p></li>
<li><p>What interface(s) should be given for plugin installation? To what extent should plugins be isolated from each other?</p></li>
<li><p>Some plugins will not use all hooks. Purebred might end up having many hooks, but most plugins will use only one or a few of them. To make it convenient to define plugins, I can define a helper function to construct a new plugin whose hooks are all no-ops. Plugin implementers can override the hooks they need.</p></li>
<li><p>Some plugins might need to modify the UI and/or propagate data around. For example, an OpenPGP plugin should let users choose whether to encrypt, sign, or do nothing with an outbound email. I haven’t solved this problem yet, but I’ll need to, somehow.</p></li>
</ul>
<h2 id="conclusion">Conclusion <a href="#conclusion" class="section">§</a></h2>
<p>My goal was to design a plugin system for Purebred offering <strong>composition</strong>; <strong>capabilities</strong> expressed through <strong>human-friendly</strong> types, enforced by the type system; and <strong>abstract</strong> plugin implementations so that the main program can evolve. Additionally, there had to be a way to provide <strong>configuration</strong> to plugins that require it. The prototype plugin system described in this post satisfies these requirements.</p>
<p>I left several regions of the plugin system design space unexplored, including dynamic (re)loading of plugins and plugin-specific data and state. These are interesting and challenging problems, but they are not problems that the Purebred project needs to solve right now.</p>
<p>The next step is to take what I’ve learned from this prototype and implement it in Purebred. There will be some new challenges there, and I expect the experience to provide ample material for a follow-up blog post—or several.</p>
</div>
<div id="postFooter">
    <div id="recent">
Recent posts:
<ul>
    
        <li>
            <a href="../posts/2021-11-12-haddock-disambiguation.html">Haddock: disambiguating types and values</a>
        </li>
    
        <li>
            <a href="../posts/2021-10-12-aeson-hash-flooding-protection.html">How to protect <em>aeson</em> code from hash flooding</a>
        </li>
    
        <li>
            <a href="../posts/2021-10-03-hedgehog-reuse-random.html">Reusing random generators in Hedgehog</a>
        </li>
    
        <li>
            <a href="../posts/2021-07-26-hakyll-without-sources.html">Hakyll how-to: pages without source files</a>
        </li>
    
        <li>
            <a href="../posts/2021-06-11-hakyll-abstracts.html">Generating abstracts for Hakyll articles</a>
        </li>
    
</ul>

<div id="recentLinks">
    <a type="application/atom+xml" href="../atom.xml">Atom feed</a>
     <!-- em space -->
    <a href="../archive.html">All posts…</a>
</div>

</div>

    <div id="license">
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
    </a>
    <br />
    Except where otherwise noted, this work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>.
</div>

</div>

        </div>
        <div class="clear"></div>
        <div id="footer">
            Generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
