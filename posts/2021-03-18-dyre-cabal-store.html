<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>pureblog - How Dyre works with Cabal Nix-style builds</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">pureblog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div class="info">
    
    Tags: <a title="All pages tagged 'dyre'." href="../tags/dyre.html">dyre</a>, <a title="All pages tagged 'packages'." href="../tags/packages.html">packages</a>, <a title="All pages tagged 'ghc'." href="../tags/ghc.html">ghc</a>, <a title="All pages tagged 'cabal'." href="../tags/cabal.html">cabal</a>
    
</div>

<div id="postContent">
    <h1 id="how-dyre-works-with-cabal-nix-style-builds">How Dyre works with Cabal Nix-style builds</h1>
<p><a href="https://hackage.haskell.org/package/dyre">Dyre</a> is a tool for Haskell program configuration by (re)compilation. In <a href="2021-02-21-dyre-0.9-rc.html">my previous post</a> I discussed the changes planned for the Dyre 0.9 release. That release happened a couple of days ago… but I soon discovered a critical bug in Dyre’s support for <em>cabal-install</em> Nix-style local builds.</p>
<p>I have now <a href="https://github.com/willdonnelly/dyre/commit/414d961222b5b864933f35f0a0d74b1a2f501a23">fixed the bug</a> and <a href="https://hackage.haskell.org/package/dyre-0.9.1">released v0.9.1</a>. As a result of the experience I decided to write this post about how Nix-style local builds work, and how Dyre works with programs built and installed that way.</p>
<h2 id="ghc-and-package-databases">GHC and package databases <a href="#ghc-and-package-databases">§</a></h2>
<p>Haskell packages are installed in <em>package databases</em>. The package database contains libraries’ object code and Haskell interface (<code>*.hi</code>) files, as well as package descriptions and references to the library’s dependencies. When compiling and linking a program or library, GHC looks for dependencies in the configured package database(s).</p>
<p>By default, GHC knows about two package databases. The <em>global package database</em> is where <em>base</em> and the other libraries bundled with GHC are installed. The database location is tied to the GHC release; for example: <code>/usr/lib64/ghc-8.8.4/package.conf.d</code>. On most operating systems, the system package manager will install Haskell libraries in the global package database.</p>
<p>GHC also knows about <em>user package databases</em>. On Unix systems these are located at <code>~/.ghc/ARCH-OS-GHCVER/package.conf.d</code>. As the name and location suggests, unprivileged users can install packages to their user package database. GHC will also search for dependencies in there, unless told otherwise.</p>
<p><em>cabal-install</em> (the <code>cabal</code> program) and the system package manager take care of these package databases. Users don’t normally need to look into or modify them. For the curious (or cursed), you can use the <code>ghc-pkg</code> program to inspect and modify package databases. For example, here’s how to list the contents of the global package database:</p>
<pre class="shell"><code>% ghc-pkg --global list
/usr/lib64/ghc-8.8.4/package.conf.d
    Cabal-3.0.1.0
    Glob-0.10.0
    HTTP-4000.3.14
    HsYAML-0.2.1.0
    HsYAML-aeson-0.2.0.0
    … (many more)</code></pre>
<p>Let’s have a look at one of the records in the global package database:</p>
<pre><code>% cat /usr/lib64/ghc-8.8.4/package.conf.d/mtl-2.2.2.conf
name:                 mtl
version:              2.2.2
visibility:           public
id:                   mtl-2.2.2
key:                  mtl-2.2.2
license:              BSD-3-Clause
maintainer:           Edward Kmett &lt;ekmett@gmail.com&gt;
author:               Andy Gill
homepage:             http://github.com/haskell/mtl
synopsis:             Monad classes, using functional dependencies
description:
    … (elided)
category:             Control
abi:                  7208c11cc6615ddff9d903a90a9878f8
exposed:              True
exposed-modules:
    … (elided)
import-dirs:          /usr/lib64/ghc-8.8.4/mtl-2.2.2
library-dirs:         /usr/lib64/ghc-8.8.4/mtl-2.2.2
dynamic-library-dirs: /usr/lib64
data-dir:             /usr/share/x86_64-linux-ghc-8.8.4/mtl-2.2.2
hs-libraries:         HSmtl-2.2.2
depends:              base-4.13.0.0 transformers-0.5.6.2
haddock-interfaces:   /usr/share/doc/ghc/html/libraries/mtl-2.2.2/mtl.haddock
haddock-html:         /usr/share/doc/ghc/html/libraries/mtl-2.2.2</code></pre>
<p>Most fields are self explanatory, but some need a little explanation:</p>
<ul>
<li><p><strong><code>id</code></strong> is the <em>unit ID</em> that uniquely identifies the package. In the example above it includes the package <code>name</code> and <code>version</code>; a unit ID can also include other identifying data.</p></li>
<li><p><strong><code>depends</code></strong> lists the direct dependencies of this package, as unit IDs.</p></li>
<li><p><strong><code>exposed</code></strong> controls whether the modules in the package are available to import during compilation. This is just the default. GHC command line options and <a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/packages.html#package-environments"><em>package environment files</em></a> can alter package visibility.</p></li>
</ul>
<p>For more details see the <a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/packages.html"><em>Packages</em> chapter</a> of the GHC User’s Guide.</p>
<h2 id="cabal-install-and-package-databases"><em>cabal-install</em> and package databases <a href="#cabal-install-and-package-databases">§</a></h2>
<p>In earlier times, the <em>cabal-install</em> build tool would install all dependencies of a package into the global or user package database. But when you have multiple packages with conflicting dependencies, this approach does not work. It also makes updating packages very risky. Updating one package (because some dependent program or library requires a newer version) would often break other installed dependent packages.</p>
<p><em>cabal-install</em>’s first solution to this problem was <a href="https://cabal.readthedocs.io/en/3.2/installing-packages.html#developing-with-sandboxes">per-project sandboxes</a>. When using a sandbox, <em>cabal-install</em> installs dependencies (those that are not in the global or user package database) under <code>.cabal-sandbox/</code> in the project directory. Sandboxes are isolated from each other. This solved the main problem but introduced another. Many projects meant many sandboxes, wasting a lot of time and space as common dependencies got built over and over again, in different sandboxes.</p>
<p>Furthermore, users had to deliberately create sandboxes. The problematic behaviour (install to the user package database) was the default behaviour. You had to <em>know</em> about, and use, sandboxes to avoid trouble.</p>
<div class="note">
<p>Sandbox support was removed in <em>cabal-install</em> 3.4.</p>
</div>
<h2 id="nix-style-local-builds">Nix-style local builds <a href="#nix-style-local-builds">§</a></h2>
<p><em>cabal-install</em> since version 1.24 supports <a href="https://cabal.readthedocs.io/en/3.4/nix-local-build-overview.html"><em>Nix-style local builds</em></a>. It is the default behaviour (i.e. what <code>cabal build</code> does) since version 2.0. The feature is also called <em><code>v2-build</code></em> or <em><code>new-build</code></em></p>
<p>This build system caches dependencies in a package database at <code>~/.cabal/store/GHCVER/package.db</code>. I call this package database the <strong><em>Cabal store</em></strong>. The unit IDs of packages in the Cabal store include the name, version, and a digest (hash) of the entire package contents, which prevents collisions. For example, <code>ghc-pkg</code> can print the unit IDs of all the variants of <em>purebred-email</em> in my Cabal store. Note that there are multiple variants even of particular versions (some were development builds):</p>
<pre class="shell"><code>% ghc-pkg \
    --package-db ~/.cabal/store/ghc-8.8.4/package.db \
    field purebred-email id \
    | sort
id: purebred-email-0.4.2-904f4dca7fc38b0732875f3118229289f0a854a1b29ceb6f61952455fc536475
id: purebred-email-0.4.2-937f77fe675ce899d5b8bf4e451f09d83f458db59751e28d393dafa5d0e46e80
id: purebred-email-0.4.3-12899342c54e9be6f8bfabf40ea03e13ba08a15da3d519a6ba6c16b5e8a2fdf7
id: purebred-email-0.4.3-132e0f4a654056feced84d90a98b5cc3f8635b2a56e2821e5193cace1a73946d
id: purebred-email-0.5.0-04c8aceff5a68a6eb0537475f958dcb2aa763675c36a57893119534e690ebfe7
id: purebred-email-0.5.0-0a5c9f98d485c79e5bbbb3eefbc8239c4e5a74dc26d03fc0a12ce8a45a304c8d
id: purebred-email-0.5.0-4c9fa1b81ac8638346df176519fee11541953f243502699a8693f69fafc2293f
id: purebred-email-0.5.0-cc781fa90dc462076d5be322d38e59b76a1604cb866e8b6a15a150653e9f6595
id: purebred-email-0.5.0-e8d411ef4593a88bbd40293b523c03079a01138f9bb1278781a4eb5a15cf461f</code></pre>
<p>If we inspect the <code>depends</code> fields of one of these packages, we see a mix of unit IDs with and without hashes. The ones without hashes will be located in the global package database, and the ones with hashes are other packges in the Cabal store:</p>
<pre class="shell"><code>% ghc-pkg \
    --package-db ~/.cabal/store/ghc-8.8.4/package.db \
    --unit-id \
    field purebred-email-0.4.3-12899342c54e9be6f8bfabf40ea03e13ba08a15da3d519a6ba6c16b5e8a2fdf7 \
    depends
depends: attoparsec-0.13.2.4-6pdJvsCYDtQ1ZikLcQPH6i base-4.13.0.0
         base64-bytestring-1.0.0.3-6nNbupf0oNc9ekFOSwyfJw
         bytestring-0.10.10.1 case-insensitive-1.2.1.0-GK3nA3zBZszGkFybfKiPH
         concise-0.1.0.1-9e9a3f5d1a0cb55cc27d6ed4559347484ed0182db25d17f54fecc4cb16c664f3
         deepseq-1.4.4.0 lens-4.18.1-1Ci7u4sFw8083dvBI6HqCw
         semigroupoids-5.3.4-3QeAlkxMhKa1rjJSsIVWj7
         semigroups-0.19.1-LKdktuRRdRZ1yx9gBXzSbK
         stringsearch-0.3.6.6-ea9567d6b6c3d6f0b0229eaa65b28da6602e2135e50018657a4d1545dc4a0d0c
         text-1.2.4.0 time-1.9.3</code></pre>
<p>Object code filenames of libraries installed in the Cabal store incorporate the full unit ID:</p>
<pre class="shell"><code>% cd ~/.cabal/store/ghc-8.8.4/purebred-email-0.4.3-12899342c54e9be6f8bfabf40ea03e13ba08a15da3d519a6ba6c16b5e8a2fdf7/lib
% ls
Data
libHSpurebred-email-0.4.3-12899342c54e9be6f8bfabf40ea03e13ba08a15da3d519a6ba6c16b5e8a2fdf7.a
libHSpurebred-email-0.4.3-12899342c54e9be6f8bfabf40ea03e13ba08a15da3d519a6ba6c16b5e8a2fdf7-ghc8.8.4.so</code></pre>
<p>To assist the dynamic linker, the <code>RUNPATH</code> attribute in dynamically linked executables and shared objects includes the subdirectories of the Cabal store where the needed shared objects are located:</p>
<pre class="shell"><code>% objdump -x libHSpurebred-email-0.4.3-12899342c54e9be6f8bfabf40ea03e13ba08a15da3d519a6ba6c16b5e8a2fdf7-ghc8.8.4.so \
    | grep RUNPATH \
    | awk '{ print $2 }' \
    | tr : '\n' \
    | sort
/home/ftweedal/.cabal/store/ghc-8.8.4/concise-0.1.0.1-9e9a3f5d1a0cb55cc27d6ed4559347484ed0182db25d17f54fecc4cb16c664f3/lib
/home/ftweedal/.cabal/store/ghc-8.8.4/stringsearch-0.3.6.6-ea9567d6b6c3d6f0b0229eaa65b28da6602e2135e50018657a4d1545dc4a0d0c/lib
/usr/lib64
/usr/lib64/ghc-8.8.4/rts</code></pre>
<p>Executables are installed in the Cabal store and referenced by a symbolic link installed in <code>~/.cabal/bin/</code> or a similar location.</p>
<pre class="shell"><code>% which purebred
~/.cabal/bin/purebred
% readlink ~/.cabal/bin/purebred
../store/ghc-8.8.4/purebred-0.1.0.0-ffa8d363a9788cf11f71e6dbad787526a4fa1f9f750969f4d55036610f5cb027/bin/purebred</code></pre>
<h2 id="dyre-and-the-cabal-store">Dyre and the Cabal store <a href="#dyre-and-the-cabal-store">§</a></h2>
<p>When using <em>cabal-install</em>, the details about the Cabal store are hidden from the user. But a Dyre-enabled program does not have the luxury of using <em>cabal-install</em> when (re)compiling a custom executable. We cannot assume that the <code>cabal</code> program is available. Even if we did make that assumption, using <em>cabal-install</em> would introduce <strong>a lot</strong> of additional complexity. And maintenance overhead, because <em>cabal-install</em>’s behaviour is continually evolving, whereas GHC’s command line interface is stable.</p>
<p>So Dyre invokes GHC directly. When a Dyre application’s main library is in the global or user package database, GHC finds it and all is well. But when the library is in the Cabal store, GHC cannot find it:</p>
<pre class="shell"><code>% purebred
Configuration '/home/fraser/.config/purebred/purebred.hs' changed. Recompiling.
Error occurred while loading configuration file.
purebred: 
/home/fraser/.config/purebred/purebred.hs:5:1: error:
    Could not find module ‘Purebred’
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
5 | import Purebred
  | ^^^^^^^^^^^^^^^

CallStack (from HasCallStack):
  error, called at src/Purebred.hs:347:69 in purebred-0.1.0.0-95b0b0050ea0df258f6dce7f45c7c58630549c4395e1e143f3e0915c057e8cbc:Purebred</code></pre>
<p>To overcome this, Dyre needs to detect when the application library is installed in the Cabal store, and pass some additional command line options to GHC:</p>
<ul>
<li><p>The <code>-package-db &lt;FILE&gt;</code> option adds the package database at <code>FILE</code> to the list of databases GHC searches. Dyre uses this option to add the Cabal store.</p></li>
<li><p>The <code>-package-id &lt;UNIT-ID&gt;</code> option <em>exposes</em> the package identified by <code>UNIT-ID</code>, making its public modules available for import. Dyre uses this option to expose the main application library.</p></li>
</ul>
<p>In Dyre’s implementation, the <code>getCabalStoreGhcArgs</code> function computes these options. It is applied to a Dyre project name and a library path. If the library path is in the Cabal store <em>and</em> matches the project name, Dyre derives the appropriate <code>-package-db</code> and <code>-package-id</code> options.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">System.FilePath</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  (joinPath, splitPath, dropTrailingPathSeparator)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="ot">getCabalStoreGhcArgs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>getCabalStoreGhcArgs proj <span class="ot">=</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    mkArgs <span class="op">.</span> go <span class="op">.</span> <span class="fu">fmap</span> dropTrailingPathSeparator <span class="op">.</span> splitPath</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>  go (<span class="st">&quot;.cabal&quot;</span> <span class="op">:</span> <span class="st">&quot;store&quot;</span> <span class="op">:</span> hc <span class="op">:</span> pid <span class="op">:</span> _) <span class="ot">=</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="kw">case</span> splitOn <span class="ch">'-'</span> pid <span class="kw">of</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>      [name, _version, _hash] <span class="op">|</span> name <span class="op">==</span> proj</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>        <span class="ot">-&gt;</span> <span class="dt">Just</span> (pid, [<span class="st">&quot;.cabal&quot;</span>, <span class="st">&quot;store&quot;</span>, hc, <span class="st">&quot;package.db&quot;</span>])</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>      _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  go (h <span class="op">:</span> t<span class="op">@</span>(_ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _)) <span class="ot">=</span> <span class="fu">fmap</span> (h<span class="op">:</span>) <span class="op">&lt;$&gt;</span> go t</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  go _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>  mkArgs <span class="dt">Nothing</span> <span class="ot">=</span> []</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>  mkArgs (<span class="dt">Just</span> (unitId, pkgDb)) <span class="ot">=</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>    [<span class="st">&quot;-package-db&quot;</span>, joinPath pkgDb, <span class="st">&quot;-package-id&quot;</span>, unitId]</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a>  splitOn a l <span class="ot">=</span> <span class="kw">case</span> <span class="fu">span</span> (<span class="op">/=</span> a) l <span class="kw">of</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a>    (h, []) <span class="ot">-&gt;</span> [h]</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a>    (h, _ <span class="op">:</span> t) <span class="ot">-&gt;</span> h <span class="op">:</span> splitOn a t</span></code></pre></div>
<div class="note">
<p><em>cabal-install</em> lets you <a href="https://cabal.readthedocs.io/en/3.4/cabal-project.html?highlight=store-dir#cmdoption-store-dir">override the Cabal store directory</a>. Dyre assumes the default <code>~/.cabal/store/</code>. If the Cabal store is not in the expected place, the detection logic fails.</p>
</div>
<p>The final piece of the puzzle is how Dyre learns the application’s library directory that will be the <code>FilePath</code> argument to <code>getCabalStoreGhcArgs</code>. Dyre itself is just a library. We rely on the main program to tell Dyre where its library is located. The only alternative I know of is brittle, operating system-specific hacks.</p>
<p>Cabal packages can make use of an auto-generated <a href="https://cabal.readthedocs.io/en/3.4/cabal-package.html#accessing-data-files-from-package-code"><code>Paths_&lt;pkgname&gt;</code> module</a>. It provides <code>IO</code> actions that return the installation paths of the package (object files, binaries, data and so on), including:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">getLibDir ::</span> <span class="dt">IO</span> <span class="dt">FilePath</span></span></code></pre></div>
<p>Dyre applications can read this value and pass it to Dyre via the <a href="https://hackage.haskell.org/package/dyre-0.9.1/docs/Config-Dyre.html#v:includeDirs"><code>includeDirs</code></a> field in the <code>Params</code> object. Here is a simplified example:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">MyApp</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Config.Dyre</span> <span class="kw">as</span> <span class="dt">Dyre</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Paths_myapp</span> (getLibDir)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Configuration</span> <span class="ot">=</span> …</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="ot">defaultConfig ::</span> <span class="dt">Configuration</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>defaultConfig <span class="ot">=</span> …</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="ot">realMain ::</span> <span class="dt">Configuration</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>realMain <span class="ot">=</span> …</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>  libdir <span class="ot">&lt;-</span> getLibDir</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>  <span class="kw">let</span> params <span class="ot">=</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>        ( Dyre.newParams <span class="st">&quot;myapp&quot;</span> realMain (<span class="fu">const</span> <span class="fu">error</span>) )</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a>        { Dyre.includeDirs <span class="ot">=</span> [libdir] }</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>  Dyre.wrapMain params defaultConfig</span></code></pre></div>
<div class="note">
<p>For Cabal store detection to work, the Dyre project name (<code>myapp</code> in the example above), <strong>must</strong> be the same as the library package name. Otherwise <code>getCabalStoreGhcArgs</code> will fail to detect the package ID to expose.</p>
</div>
<p>With this small additional behaviour in place, Dyre detects that the library is in a Cabal store and passes the extra CLI options to GHC. GHC finds the library and compiles the program successfully:</p>
<pre class="shell"><code>% purebred
Configuration '/home/fraser/.config/purebred/purebred.hs' changed.
Recompiling.
Program reconfiguration successful.
Launching custom binary /home/fraser/.cache/purebred/purebred-linux-x86_64
… (realMain executes)</code></pre>
<h2 id="discussion">Discussion <a href="#discussion">§</a></h2>
<p>It is unfortunate that the author of a Dyre application must do extra work to enable it to work with the Cabal store. Even though it is a small effort, it is something most programs will want to do. I have so far been unable to conceive a robust solution that avoids this work.</p>
<p>Dyre pre-0.9 did not have this feature. To enable <a href="https://github.com/purebred-mua/purebred">Purebred</a> to work with the Cabal store, we performed the detection and constructed the extra GHC options ourselves. Then we passed the extra options to Dyre via the <a href="https://hackage.haskell.org/package/dyre-0.9.1/docs/Config-Dyre.html#v:ghcOpts"><code>ghcOpts</code></a> fields of the <code>Params</code> type. This behaviour was ported to Dyre more or less <em>as-is</em> for the 0.9 release. Except for the bit that I forgot to port, which was restored in v0.9.1.</p>
<p>My Purebred co-author reported a regression with Nix support in Dyre 0.9.x. Under Nix, GHC fails to find the application library during custom binary compilation. I suspect the cause is an incidental behavioural change as a result of porting the detection logic from Purebred to Dyre. But I have not yet started a proper investigation.</p>
</div>
<div id="postFooter">
    <div id="recent">
Recent posts:
<ul>
    
        <li>
            <a href="../posts/2021-07-26-hakyll-without-sources.html">Hakyll how-to: pages without source files</a>
        </li>
    
        <li>
            <a href="../posts/2021-06-11-hakyll-abstracts.html">Generating abstracts for Hakyll articles</a>
        </li>
    
        <li>
            <a href="../posts/2021-05-23-tax-combinators.html">A combinator library for taxes</a>
        </li>
    
        <li>
            <a href="../posts/2021-05-12-types-garden-path.html">Type-guided development and garden paths</a>
        </li>
    
        <li>
            <a href="../posts/2021-03-30-purebred-plugins-implementation.html">Purebred plugin system: implementation</a>
        </li>
    
</ul>

<div id="recentLinks">
    <a type="application/atom+xml" href="../atom.xml">Atom feed</a>
     <!-- em space -->
    <a href="../archive.html">All posts…</a>
</div>

</div>

    <div id="license">
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
    </a>
    <br />
    Except where otherwise noted, this work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>.
</div>

</div>

        </div>
        <div class="clear"></div>
        <div id="footer">
            Generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
